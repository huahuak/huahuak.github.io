<!DOCTYPE html>
<html lang="en"
  dir="ltr">

<head>
  
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)'], ['$', '$']]  
    }
  };
</script>
  
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title> | </title>

      <link rel="stylesheet" href="/css/main.min.4e3925258a07dcd1db9457696be79fd505b229e2280d31f3f622c14c35c26655.css" integrity="sha256-TjklJYoH3NHblFdpa&#43;ef1QWyKeIoDTHz9iLBTDXCZlU=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/var.min.f4ad28441b010d71b331e4a3acd0878a1f12df0c47c4e6d09c5087fa963c50f8.css" integrity="sha256-9K0oRBsBDXGzMeSjrNCHih8S3wxHxObQnFCH&#43;pY8UPg=" crossorigin="anonymous">


      <script src="/js/main.f2979a93a325fecf9605263bd141398a311c8e23388ed7dcff74f92f7e632866.js" integrity="sha256-8peak6Ml/s&#43;WBSY70UE5ijEcjiM4jtfc/3T5L35jKGY=" crossorigin="anonymous"></script>


<link rel="icon" type="image/ico" href="/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="/favicon.ico">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

</head>

<body>
  <div class="aside-layout">
    <aside id="sidebar"> <header>
  <div style="display: flex;">
    <button id="sidebar-lhs-button" onclick="toggleVisibility()" class="sidebar-ico"></button>
  </div>

  <div>
    <nav aria-label="breadcrumb" class="breadcrumb" style="display: flex; align-items: center;">
  <style>
    ol {
      margin: 0;
    }

    li {
      margin: 0;
    }

    .breadcrumb ol {
      padding-left: 0;
    }

    .breadcrumb li {
      display: inline;
    }

    .breadcrumb li:not(:last-child)::after {
       
      color: var(--blue);
      content: "·";
    }
  </style>
  <ol>
    
    <li>
      <a href="/"></a>
    </li>
    
    <li>
      <a href="/programming_languages/">Programming_languages</a>
    </li>
    
    <li class="active">
      <a aria-current="page" href="/programming_languages/golang/golang/"></a>
    </li>
  </ol>
</nav>
  </div>
</header>

<div class="main-container">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#ref">Ref</a></li>
    <li><a href="#todo">TODO</a></li>
    <li><a href="#语法基础">语法基础</a>
      <ul>
        <li><a href="#for--range">for &amp; range</a></li>
        <li><a href="#select">select</a></li>
        <li><a href="#defer">defer</a></li>
        <li><a href="#panic--recover">panic &amp; recover</a></li>
        <li><a href="#make--new">make &amp; new</a></li>
      </ul>
    </li>
    <li><a href="#面向对象编程">面向对象编程</a>
      <ul>
        <li><a href="#interface--struct">interface &amp; struct</a></li>
        <li><a href="#反射">反射</a></li>
      </ul>
    </li>
    <li><a href="#标准容器">标准容器</a>
      <ul>
        <li><a href="#数组">数组</a></li>
        <li><a href="#slice">slice</a></li>
        <li><a href="#map">map</a></li>
        <li><a href="#list">List</a></li>
        <li><a href="#ring">Ring</a></li>
        <li><a href="#heap">Heap</a></li>
      </ul>
    </li>
    <li><a href="#并发编程">并发编程</a>
      <ul>
        <li><a href="#channel">Channel</a></li>
        <li><a href="#go-sync">Go Sync</a></li>
        <li><a href="#pool">Pool</a></li>
        <li><a href="#mutex--rwmutex">Mutex &amp; RWMutex</a></li>
        <li><a href="#cond">Cond</a></li>
        <li><a href="#once">Once</a></li>
        <li><a href="#waitgroup">WaitGroup</a></li>
        <li><a href="#map-1">Map</a></li>
        <li><a href="#context--定时器">Context &amp; 定时器</a></li>
        <li><a href="#context">Context</a></li>
        <li><a href="#timer">Timer</a></li>
      </ul>
    </li>
    <li><a href="#go内部实现机制">Go内部实现机制</a>
      <ul>
        <li><a href="#gmp-调度器">GMP 调度器</a></li>
        <li><a href="#网络轮询器">网络轮询器</a></li>
        <li><a href="#系统监控">系统监控</a></li>
        <li><a href="#内存分配器">内存分配器</a></li>
        <li><a href="#垃圾收集器">垃圾收集器</a></li>
        <li><a href="#gc-算法">GC 算法</a></li>
        <li><a href="#栈内存管理">栈内存管理</a></li>
      </ul>
    </li>
    <li><a href="#标准库">标准库</a>
      <ul>
        <li><a href="#go-container">Go container</a></li>
        <li><a href="#list-1">List</a></li>
        <li><a href="#ring-1">Ring</a></li>
        <li><a href="#heap-1">Heap</a></li>
        <li><a href="#nethttp">net/http</a></li>
      </ul>
    </li>
    <li><a href="#常用库">常用库</a>
      <ul>
        <li><a href="#panjf2000ants">panjf2000/ants</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div> </aside>
    <div id="right-board">
      <header> <div style="display: flex; align-items: center;">
  <button id="sidebar-rhs-button" style="display: none;" onclick="toggleVisibility()" class="sidebar-ico"></button>
  <a href="/" style="font-size: 2em; color: #222; text-decoration: none;">
    <span> HUAHUA </span>
  </a>
</div>

<div style="display: flex; align-items: center;">
  <button onclick="toggleEdit()" class="edit-ico" style="display: none;"></button>
  <button onclick="toggleSearch()" class="search-ico"></button>
  <a href="https://github.com/huahuak/huahuak.github.io">
    <span class="gh-ico"></span>
  </a>
</div>
 </header>
      <main class="center main-container">
        <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
<script src="/pagefind/pagefind-ui.js"></script>
<style>
  .pagefind-ui__result-thumb.svelte-4xnkmf.svelte-4xnkmf {
    display: none;
  }
</style>
<div id="search" style="display: none; margin-top: 0.5em;"></div>
        

<h1 id="go-quick-start">Go quick start</h1>
<h2 id="ref">Ref</h2>
<blockquote>
<p><a href="https://draveness.me/golang/">Go 语言设计与实现</a></p>
</blockquote>
<h2 id="todo">TODO</h2>
<ul>
<li><input disabled="" type="checkbox"> select/defer/panic&amp;recover</li>
<li><input disabled="" type="checkbox"> Timer: Go 定时器实现</li>
<li><input disabled="" type="checkbox"> 内存分配器/垃圾收集器/栈内存管理</li>
<li><input disabled="" type="checkbox"> Json/HTTP/数据库等标准库</li>
<li><input disabled="" type="checkbox"> 同步原语拓展部分 ErrGroup/Semaphore/SingleFlight</li>
<li><input disabled="" type="checkbox"> 深入理解 GMP 模型、网络轮询器</li>
<li><input disabled="" type="checkbox"> Go Lambda 变量逃逸</li>
<li><input disabled="" type="checkbox"> nil and &hellip;args?</li>
<li><input disabled="" type="checkbox"> sync.pool 原理</li>
</ul>
<h2 id="语法基础">语法基础</h2>
<h3 id="for--range">for &amp; range</h3>
<p>for range 是 Go 中常用的范围遍历方法，在 Go 的实现中，会将 for range 转换为普通的 for 循环进行处理。</p>
<p><strong>数组和切片</strong>，数组和切片可以通过 for range 进行遍历，可细分为三种不同的遍历，即是否使用 range 返回的 index 和 value。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000">arr</span> <span style="color:#000">:=</span> [<span style="color:#000">...</span>]<span style="color:#a90d91">int</span>{<span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">2</span>, <span style="color:#1c01ce">3</span>}
</span></span><span style="display:flex;"><span><span style="color:#a90d91">for</span> <span style="color:#a90d91">range</span> <span style="color:#000">arr</span> {}
</span></span><span style="display:flex;"><span><span style="color:#a90d91">for</span> <span style="color:#000">_</span> = <span style="color:#a90d91">range</span> <span style="color:#000">arr</span> {}
</span></span><span style="display:flex;"><span><span style="color:#a90d91">for</span> <span style="color:#000">_</span>, <span style="color:#000">_</span> = <span style="color:#a90d91">range</span> <span style="color:#000">arr</span> {}
</span></span></code></pre></div><p>在 for range 实现中，会先通过 len( ) 方法获取 arr 的长度，作为 for 的遍历次数，因此在 for range 中对 arr 进行修改不能够改变 for range 的遍历次数。如下示例所示。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000">arr</span> <span style="color:#000">:=</span> []<span style="color:#a90d91">int</span>{<span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">2</span>, <span style="color:#1c01ce">3</span>}
</span></span><span style="display:flex;"><span><span style="color:#a90d91">for</span> <span style="color:#a90d91">range</span> <span style="color:#000">arr</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">arr</span> = <span style="color:#a90d91">append</span>(<span style="color:#000">arr</span>, <span style="color:#1c01ce">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#000">fmt</span>.<span style="color:#000">Println</span>(<span style="color:#c41a16">&#34;appended arr: &#34;</span>, <span style="color:#000">arr</span>)
</span></span></code></pre></div><p>并且，在 for range 中得到 value，不是 arr 中的 value，而是 Go 将 for range 转换为 for 之后，在 for 中拷贝了对应 arr 值的一个临时变量。观察以下代码输出，将发现 v 的地址不随 for 循环而改变，说明 v 指向的地址并不是 arr 中的变量所在内存。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">for</span> <span style="color:#000">_</span>, <span style="color:#000">v</span> <span style="color:#000">:=</span> <span style="color:#a90d91">range</span> <span style="color:#000">arr</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">fmt</span>.<span style="color:#000">Println</span>(<span style="color:#c41a16">&#34;v addr: &#34;</span>, <span style="color:#000">&amp;</span><span style="color:#000">v</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为上述原因，直接通过切片的方式在 for range 中删除元素将导致错误的预期结果。如以下代码所示，该代码不能够正确的删除 arr 中的所有元素，而将导致访问越界的错误。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">for</span> <span style="color:#000">i</span> <span style="color:#000">:=</span> <span style="color:#a90d91">range</span> <span style="color:#000">arr</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">arr</span> = <span style="color:#a90d91">append</span>(<span style="color:#000">arr</span>[<span style="color:#1c01ce">0</span>:<span style="color:#000">i</span>], <span style="color:#000">arr</span>[<span style="color:#000">i</span><span style="color:#000">+</span><span style="color:#1c01ce">1</span>:]<span style="color:#000">...</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">fmt</span>.<span style="color:#000">Println</span>(<span style="color:#000">arr</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>正确的删除 for range 中的变量的做法是，使用临时内存将不需要删除的变量进行拷贝。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000">result</span> <span style="color:#000">:=</span> []<span style="color:#a90d91">int</span>{}
</span></span><span style="display:flex;"><span><span style="color:#a90d91">for</span> <span style="color:#000">i</span> <span style="color:#000">:=</span> <span style="color:#a90d91">range</span> <span style="color:#000">arr</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">arr</span>[<span style="color:#000">i</span>] &lt; <span style="color:#1c01ce">2</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">result</span> = <span style="color:#a90d91">append</span>(<span style="color:#000">result</span>, <span style="color:#000">arr</span>[<span style="color:#000">i</span>])
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#000">fmt</span>.<span style="color:#000">Println</span>(<span style="color:#000">result</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#177500">// 一种会改变 arr 顺序，但不需要额外内存空间的方法
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#000">j</span> <span style="color:#000">:=</span> <span style="color:#1c01ce">0</span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">for</span> <span style="color:#000">i</span> <span style="color:#000">:=</span> <span style="color:#a90d91">range</span> <span style="color:#000">arr</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">if</span> <span style="color:#000">arr</span>[<span style="color:#000">i</span>] <span style="color:#000">&gt;=</span> <span style="color:#1c01ce">2</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000">arr</span>[<span style="color:#000">i</span>] = <span style="color:#000">arr</span>[<span style="color:#000">j</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#000">j</span><span style="color:#000">++</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#000">arr</span> = <span style="color:#000">arr</span>[<span style="color:#000">j</span>:]
</span></span><span style="display:flex;"><span><span style="color:#000">fmt</span>.<span style="color:#000">Println</span>(<span style="color:#000">arr</span>)
</span></span></code></pre></div><ul>
<li><input disabled="" type="checkbox"> map、string、channel 的 for range 分析</li>
</ul>
<h3 id="select">select</h3>
<h3 id="defer">defer</h3>
<h3 id="panic--recover">panic &amp; recover</h3>
<h3 id="make--new">make &amp; new</h3>
<ul>
<li>
<p>make 关键字返回 slice、hash、chan 等内置数据结构的结构体。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">make</span>([]<span style="color:#a90d91">int</span>, <span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">5</span>) <span style="color:#177500">// 参数分别为（初始化数据类型，长度，容量）
</span></span></span></code></pre></div></li>
<li>
<p>new 只返回对应数据结构体大小的指针，并将指针指向的内存置零。</p>
</li>
</ul>
<h2 id="面向对象编程">面向对象编程</h2>
<h3 id="interface--struct">interface &amp; struct</h3>
<p>interface 实现了一种抽象，使得模块之间通过接口进行通信，而不关注接口背后具体的实现。</p>
<p>在 Go 中，interface 分为 iface 和 eface 两种，interface 本质上是一种特殊的结构体。</p>
<ul>
<li>其中 iface 是有方法的 interface，iface 结构体包含了接口类型和具体类型，数据指针等内容。</li>
<li>而 eface 是没有方法的、特殊的 interface，其结构体中仅包含具体类型和数据指针。</li>
</ul>
<p><strong>类型转换</strong>，类型转换是指实现了不同 interface 的变量转换为某一抽象的 interface 的过程。</p>
<ul>
<li>
<p>如果变量是<strong>结构体指针</strong>，则转换后的 iface 和 eface 中的数据指针指向结构体指针对应的结构体内存。</p>
</li>
<li>
<p>而当变量是<strong>结构体</strong>，Go 首先将结构体进行拷贝，然后使 iface 和 eface 中的数据指针指向拷贝后的内存。</p>
</li>
<li>
<p>因此，对结构体转换而来的 interface，将 interface 通过<strong>类型断言</strong>转换为原类型变量后，与转换前的变量是不同的变量。如下代码所示，foo 与 foo2 是不同的变量，foo 不会因 foo2 的修改而发生改变。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">type</span> <span style="color:#000">Foo</span> <span style="color:#a90d91">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">v</span> <span style="color:#a90d91">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">var</span> <span style="color:#000">fooInter</span> <span style="color:#000">FooInterface</span> = <span style="color:#000">foo</span>
</span></span><span style="display:flex;"><span><span style="color:#000">foo2</span> <span style="color:#000">:=</span> <span style="color:#000">fooInter</span>.(<span style="color:#000">Foo</span>)
</span></span><span style="display:flex;"><span><span style="color:#000">foo2</span>.<span style="color:#000">v</span> = <span style="color:#1c01ce">99</span>
</span></span><span style="display:flex;"><span><span style="color:#000">fmt</span>.<span style="color:#000">Println</span>(<span style="color:#c41a16">&#34;convert struct to interface, copy happen, old foo still is&#34;</span>, <span style="color:#000">foo</span>)
</span></span></code></pre></div><p>相同的，对 iface 而言，由<strong>结构体接收者</strong>实现的 interface 方法是不能够改变调用者结构体中的内部变量。由<strong>结构体指针接收者</strong>实现的 interface 方法能够改变调用者结构体中内部的变量，但是结构体初始化的变量不能够转换为该由结构体指针实现方法的 interface，因为结构体在转换为 iface 时将发生拷贝，此时 Go 不能够找到对应的结构体指针接收者。示例如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">type</span> <span style="color:#000">FooInterface</span> <span style="color:#a90d91">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">hello</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">type</span> <span style="color:#000">Foo</span> <span style="color:#a90d91">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">v</span> <span style="color:#a90d91">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> (<span style="color:#000">f</span> <span style="color:#000">Foo</span>) <span style="color:#000">hello</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// can&#39;t modify f because the f is a struct instead of pointer
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">f</span>.<span style="color:#000">v</span> = <span style="color:#1c01ce">999</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">interfaceExample</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">println</span>(<span style="color:#c41a16">&#34;interface example&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">foo</span> <span style="color:#000">:=</span> <span style="color:#000">Foo</span>{<span style="color:#000">v</span>: <span style="color:#1c01ce">1</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#177500">// if hello() is func(f *Foo) hello(),
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  <span style="color:#177500">// this convert is impossible.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">var</span> <span style="color:#000">fooInterface</span> <span style="color:#000">FooInterface</span> = <span style="color:#000">foo</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">fooInterface</span>.<span style="color:#000">hello</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h3 id="反射">反射</h3>
<p>反射是一种在运行时获取类型信息，并进行修改的方法。Go 中反射主要由 reflect.TypeOf 和 reflect.ValueOf 两个方法构成。TypeOf 能够获取变量的类型，ValueOf 能够获取变量的值，有了变量的类型和值，就能够实现对变量的所有操作。</p>
<p>TypeOf 方法返回一个 reflect.Type 的接口，而 ValueOf 方法返回一个 reflect.Value 的结构体。Type 接口定义了 Methods 等方法，用来获取类型拥有的方法、字段等，而 Value 定义了各种获取变量的值的方法。</p>
<p>通过反射调用变量的方法，改变变量的值如下代码所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">type</span> <span style="color:#000">Foo</span> <span style="color:#a90d91">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">v</span> <span style="color:#a90d91">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000">C</span> <span style="color:#a90d91">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">reflectExample</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">println</span>(<span style="color:#c41a16">&#34;reflect example&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">foo</span> <span style="color:#000">:=</span> <span style="color:#000">Foo</span>{<span style="color:#000">v</span>: <span style="color:#1c01ce">1</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#000">fooTyp</span> <span style="color:#000">:=</span> <span style="color:#000">reflect</span>.<span style="color:#000">TypeOf</span>(<span style="color:#000">foo</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">nMethod</span> <span style="color:#000">:=</span> <span style="color:#000">fooTyp</span>.<span style="color:#000">NumMethod</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">for</span> <span style="color:#000">i</span> <span style="color:#000">:=</span> <span style="color:#1c01ce">0</span>; <span style="color:#000">i</span> &lt; <span style="color:#000">nMethod</span>; <span style="color:#000">i</span><span style="color:#000">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">fooTyp</span>.<span style="color:#000">Method</span>(<span style="color:#000">i</span>).<span style="color:#000">Func</span>.<span style="color:#000">Call</span>([]<span style="color:#000">reflect</span>.<span style="color:#000">Value</span>{})
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#000">fooVal</span> <span style="color:#000">:=</span> <span style="color:#000">reflect</span>.<span style="color:#000">ValueOf</span>(<span style="color:#000">&amp;</span><span style="color:#000">foo</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">fooVal</span>.<span style="color:#000">Elem</span>().<span style="color:#000">Field</span>(<span style="color:#1c01ce">1</span>).<span style="color:#000">SetInt</span>(<span style="color:#1c01ce">99</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">fmt</span>.<span style="color:#000">Printf</span>(<span style="color:#c41a16">&#34;foo: %#v\\n&#34;</span>, <span style="color:#000">foo</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><input disabled="" type="checkbox"> 补充 TypeOf/ValueOf 等方法源码分析</li>
</ul>
<h2 id="标准容器">标准容器</h2>
<h3 id="数组">数组</h3>
<p>数组是只能存储固定数量相同类型数据的数据结构。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000">arr</span> <span style="color:#000">:=</span> [<span style="color:#1c01ce">3</span>]<span style="color:#a90d91">int</span>{<span style="color:#1c01ce">1</span>,<span style="color:#1c01ce">2</span>,<span style="color:#1c01ce">3</span>}
</span></span><span style="display:flex;"><span><span style="color:#000">arr2</span> <span style="color:#000">:=</span> [<span style="color:#000">...</span>]<span style="color:#a90d91">int</span>{<span style="color:#1c01ce">1</span>,<span style="color:#1c01ce">2</span>,<span style="color:#1c01ce">3</span>}
</span></span></code></pre></div><h3 id="slice">slice</h3>
<p>切片是一种动态数组，其容量能够动态调整。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000">slice</span> <span style="color:#000">:=</span> []<span style="color:#a90d91">int</span>{<span style="color:#1c01ce">1</span>,<span style="color:#1c01ce">2</span>,<span style="color:#1c01ce">3</span>}
</span></span><span style="display:flex;"><span><span style="color:#000">slice2</span> <span style="color:#000">:=</span> <span style="color:#a90d91">make</span>([]<span style="color:#a90d91">int</span>, <span style="color:#1c01ce">3</span>)
</span></span><span style="display:flex;"><span><span style="color:#000">slice3</span> <span style="color:#000">:=</span> <span style="color:#000">arr</span>[<span style="color:#1c01ce">0</span>:<span style="color:#1c01ce">3</span>]
</span></span><span style="display:flex;"><span><span style="color:#000">slice4</span> <span style="color:#000">:=</span> <span style="color:#000">arr</span>[<span style="color:#1c01ce">0</span>:<span style="color:#1c01ce">3</span>:<span style="color:#1c01ce">3</span>]
</span></span></code></pre></div><p>切片也能够从数组中创建，此时需要注意的是切片是底层数组的一个部分引用，对切片的修改也会同步影响对底层数组的修改，<strong>需要注意的是</strong>，当切片发生扩容时，可能会切换底层数组，即<strong>切片失去与原数组的关联</strong>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000">arr</span> <span style="color:#000">:=</span> [<span style="color:#1c01ce">3</span>]<span style="color:#a90d91">int</span>{<span style="color:#1c01ce">1</span>,<span style="color:#1c01ce">2</span>,<span style="color:#1c01ce">3</span>}
</span></span><span style="display:flex;"><span><span style="color:#000">slice3</span> <span style="color:#000">:=</span> <span style="color:#000">arr</span>[<span style="color:#1c01ce">0</span>:<span style="color:#1c01ce">3</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">sliceExample</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">println</span>(<span style="color:#c41a16">&#34;slice example&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">arr</span> <span style="color:#000">:=</span> [<span style="color:#1c01ce">3</span>]<span style="color:#a90d91">int</span>{<span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">2</span>, <span style="color:#1c01ce">3</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#000">slice</span> <span style="color:#000">:=</span> <span style="color:#000">arr</span>[<span style="color:#1c01ce">0</span>:<span style="color:#1c01ce">3</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#000">slice</span>[<span style="color:#1c01ce">1</span>] = <span style="color:#1c01ce">9</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">fmt</span>.<span style="color:#000">Println</span>(<span style="color:#c41a16">&#34;arr: &#34;</span>, <span style="color:#000">arr</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">slice</span> = <span style="color:#a90d91">append</span>(<span style="color:#000">slice</span>, <span style="color:#1c01ce">4</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">fmt</span>.<span style="color:#000">Println</span>(<span style="color:#c41a16">&#34;slice: &#34;</span>, <span style="color:#000">slice</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">fmt</span>.<span style="color:#000">Println</span>(<span style="color:#c41a16">&#34;arr: &#34;</span>, <span style="color:#000">arr</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="map">map</h3>
<p>map 是一种键值对映射的数据结构，利用 hash 函数将 key 映射到数组中的索引上，当发生碰撞上采用开放寻址法或拉链法避免冲突，hash 表需要考虑装载因子，装载因子指元素总量和数组容量的比例，因为装载因子越大，则 hash 表的性能越差，合适的装载因子能够充分利用数组容量，而不导致 hash 表的性能急剧下降。</p>
<p>map 的初始化方式包括以下两种：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000">hash</span> <span style="color:#000">:=</span> <span style="color:#a90d91">map</span>[<span style="color:#a90d91">string</span>]<span style="color:#a90d91">int</span>{}
</span></span><span style="display:flex;"><span><span style="color:#000">hash2</span> <span style="color:#000">:=</span> <span style="color:#a90d91">make</span>(<span style="color:#a90d91">map</span>[<span style="color:#a90d91">string</span>]<span style="color:#a90d91">int</span>, <span style="color:#1c01ce">0</span>)
</span></span></code></pre></div><p>map 的读写操作如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000">hash</span>[<span style="color:#c41a16">&#34;key&#34;</span>] = <span style="color:#1c01ce">1</span>
</span></span><span style="display:flex;"><span><span style="color:#000">value</span> <span style="color:#000">:=</span> <span style="color:#000">hash</span>[<span style="color:#c41a16">&#34;key&#34;</span>]
</span></span><span style="display:flex;"><span><span style="color:#000">value2</span>, <span style="color:#000">ok</span> <span style="color:#000">:=</span> <span style="color:#000">hash</span>[<span style="color:#c41a16">&#34;key&#34;</span>]
</span></span><span style="display:flex;"><span><span style="color:#a90d91">for</span> <span style="color:#000">k</span>, <span style="color:#000">v</span> <span style="color:#000">:=</span> <span style="color:#a90d91">range</span> <span style="color:#000">hash</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">println</span>(<span style="color:#000">k</span>, <span style="color:#000">v</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a90d91">delete</span>(<span style="color:#000">hash</span>, <span style="color:#c41a16">&#34;key&#34;</span>)
</span></span></code></pre></div><p>map 的数据结构如下图所示，map 由 hmap 表示，hmap 持有的 buckets 数组由 $[ ]bmap$ 表示，一般情况下，一个 bmap 结构体中存放 8 个键值对。同时，hmap 还持 overflow 数据结构，overflow 作为溢出桶减少扩容的次数（<em>下图中 buckets 与 overflow 的数量比为 1:1 并不具有适用性</em>）。</p>
<p>除了 bukets/overflow 此外，hmap 还持有 oldbuckets/oldoverflow，其作为扩容的中间状态而存在。</p>
<p><img src="golang.assets/hmap-and-buckets-20240108121201785.png" alt="https://img.draveness.me/2020-10-18-16030322432679/hmap-and-buckets.png"></p>
<ul>
<li>
<p><strong>map 扩容</strong>，当超过负载因子或者溢出桶过多时，会在向 map 赋值时触发 hashGrow() 进行扩容。扩容首先会将当前 buckets/overflow 设置为 oldbuckets/oldoverflow，然后进行渐进式的扩容，每次对 map 进行操作时，会通过 oldbuckets 是否为 nil 判断当前是否在进行扩容。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">if</span> !<span style="color:#000">h</span>.<span style="color:#000">growing</span>() <span style="color:#000">&amp;&amp;</span> (<span style="color:#000">overLoadFactor</span>(<span style="color:#000">h</span>.<span style="color:#000">count</span><span style="color:#000">+</span><span style="color:#1c01ce">1</span>, <span style="color:#000">h</span>.<span style="color:#000">B</span>) <span style="color:#000">||</span> <span style="color:#000">tooManyOverflowBuckets</span>(<span style="color:#000">h</span>.<span style="color:#000">noverflow</span>, <span style="color:#000">h</span>.<span style="color:#000">B</span>)) {
</span></span><span style="display:flex;"><span>  <span style="color:#000">hashGrow</span>(<span style="color:#000">t</span>, <span style="color:#000">h</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">goto</span> <span style="color:#000">again</span> <span style="color:#177500">// Growing the table invalidates everything, so try again
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">overLoadFactor</span>(<span style="color:#000">count</span> <span style="color:#a90d91">int</span>, <span style="color:#000">B</span> <span style="color:#a90d91">uint8</span>) <span style="color:#a90d91">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">count</span> &gt; <span style="color:#000">bucketCnt</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#a90d91">uintptr</span>(<span style="color:#000">count</span>) &gt; <span style="color:#000">loadFactorNum</span><span style="color:#000">*</span>(<span style="color:#000">bucketShift</span>(<span style="color:#000">B</span>)<span style="color:#000">/</span><span style="color:#000">loadFactorDen</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">tooManyOverflowBuckets</span>(<span style="color:#000">noverflow</span> <span style="color:#a90d91">uint16</span>, <span style="color:#000">B</span> <span style="color:#a90d91">uint8</span>) <span style="color:#a90d91">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// If the threshold is too low, we do extraneous work.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// &#34;too many&#34; means (approximately) as many overflow buckets as regular buckets.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// See incrnoverflow for more details.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">if</span> <span style="color:#000">B</span> &gt; <span style="color:#1c01ce">15</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">B</span> = <span style="color:#1c01ce">15</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// The compiler doesn&#39;t see here that B &lt; 16; mask B to generate shorter shift code.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">return</span> <span style="color:#000">noverflow</span> <span style="color:#000">&gt;=</span> <span style="color:#a90d91">uint16</span>(<span style="color:#1c01ce">1</span>)<span style="color:#000">&lt;&lt;</span>(<span style="color:#000">B</span><span style="color:#000">&amp;</span><span style="color:#1c01ce">15</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当发现目前在进行扩容时，会调用 evacuate( ) 函数执行数据迁移过程，该函数会将对 map 操作的 bucket 迁移到新的 buckets 中，同时还会根据 nevacuate 计数器，对计数器所指示的 oldbuckets 执行数据迁移。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">growWork</span>(<span style="color:#000">t</span> <span style="color:#000">*</span><span style="color:#000">maptype</span>, <span style="color:#000">h</span> <span style="color:#000">*</span><span style="color:#000">hmap</span>, <span style="color:#000">bucket</span> <span style="color:#a90d91">uintptr</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// make sure we evacuate the oldbucket corresponding
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// to the bucket we&#39;re about to use
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">evacuate</span>(<span style="color:#000">t</span>, <span style="color:#000">h</span>, <span style="color:#000">bucket</span><span style="color:#000">&amp;</span><span style="color:#000">h</span>.<span style="color:#000">oldbucketmask</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// evacuate one more oldbucket to make progress on growing
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">if</span> <span style="color:#000">h</span>.<span style="color:#000">growing</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#000">evacuate</span>(<span style="color:#000">t</span>, <span style="color:#000">h</span>, <span style="color:#000">h</span>.<span style="color:#000">nevacuate</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><strong>map hash 中取余技巧</strong>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// bucketShift returns 1&lt;&lt;b, optimized for code generation.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> <span style="color:#000">bucketShift</span>(<span style="color:#000">b</span> <span style="color:#a90d91">uint8</span>) <span style="color:#a90d91">uintptr</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// Masking the shift amount allows overflow checks to be elided.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">return</span> <span style="color:#a90d91">uintptr</span>(<span style="color:#1c01ce">1</span>) <span style="color:#000">&lt;&lt;</span> (<span style="color:#000">b</span> <span style="color:#000">&amp;</span> (<span style="color:#000">goarch</span>.<span style="color:#000">PtrSize</span><span style="color:#000">*</span><span style="color:#1c01ce">8</span> <span style="color:#000">-</span> <span style="color:#1c01ce">1</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#177500">// bucketMask returns 1&lt;&lt;b - 1, optimized for code generation.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> <span style="color:#000">bucketMask</span>(<span style="color:#000">b</span> <span style="color:#a90d91">uint8</span>) <span style="color:#a90d91">uintptr</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">bucketShift</span>(<span style="color:#000">b</span>) <span style="color:#000">-</span> <span style="color:#1c01ce">1</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000">bucket</span> <span style="color:#000">:=</span> <span style="color:#000">hash</span> <span style="color:#000">&amp;</span> <span style="color:#000">bucketMask</span>(<span style="color:#000">h</span>.<span style="color:#000">B</span>)
</span></span><span style="display:flex;"><span><span style="color:#000">b</span> <span style="color:#000">:=</span> (<span style="color:#000">*</span><span style="color:#000">bmap</span>)(<span style="color:#000">add</span>(<span style="color:#000">h</span>.<span style="color:#000">buckets</span>, <span style="color:#000">bucket</span><span style="color:#000">*</span><span style="color:#a90d91">uintptr</span>(<span style="color:#000">t</span>.<span style="color:#000">BucketSize</span>)))
</span></span></code></pre></div><p>第 12 行代码中的 $h.B$ 为 2 的指数，map 存放简直对的 bucket 数组的长度为 $2^{h.B}$，第 12 行代码即实现了对 hash 值的取余，相当于下面代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// bucket := hash &amp; ((1 &lt;&lt; h.B) - 1))
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#000">bucket</span> <span style="color:#000">:=</span> <span style="color:#000">hash</span> <span style="color:#000">%</span> <span style="color:#000">math</span>.<span style="color:#000">Pow</span>(<span style="color:#1c01ce">2</span>, <span style="color:#000">h</span>.<span style="color:#000">B</span>)
</span></span></code></pre></div><p>原理是当取余的数字是 2 的指数大小时，hash 按二进制看，其位数大于指数 h.B 的部分一定能够被指数 h.B 整除，而小于指数 h.B 的部分就是余数，通过同 $((1 << h.B) - 1))$ 相与，就能够得到取余的部分。</p>
</li>
</ul>
<h3 id="list">List</h3>
<p>List 是一个双向链表。使用 List 结构体存储头节点和链表长度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// List represents a doubly linked list.
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// The zero value for List is an empty list ready to use.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">type</span> <span style="color:#000">List</span> <span style="color:#a90d91">struct</span> {
</span></span><span style="display:flex;"><span> <span style="color:#000">root</span> <span style="color:#000">Element</span> <span style="color:#177500">// sentinel list element, only &amp;root, root.prev, and root.next are used
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">len</span>  <span style="color:#a90d91">int</span>     <span style="color:#177500">// current list length excluding (this) sentinel element
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>}
</span></span></code></pre></div><p>节点为 Element 元素。包括前后指针，和指向所属的 list 的指针，使用 any 存储任意值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// Element is an element of a linked list.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">type</span> <span style="color:#000">Element</span> <span style="color:#a90d91">struct</span> {
</span></span><span style="display:flex;"><span> <span style="color:#177500">// Next and previous pointers in the doubly-linked list of elements.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// To simplify the implementation, internally a list l is implemented
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// as a ring, such that &amp;l.root is both the next element of the last
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// list element (l.Back()) and the previous element of the first list
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// element (l.Front()).
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">next</span>, <span style="color:#000">prev</span> <span style="color:#000">*</span><span style="color:#000">Element</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#177500">// The list to which this element belongs.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">list</span> <span style="color:#000">*</span><span style="color:#000">List</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#177500">// The value stored with this element.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">Value</span> <span style="color:#000">any</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>内部实现 insert/remove/move 等基本 API 操作，衍生出公开的诸如 InsertBefore() 等 API。</p>
<p><strong>insert()</strong> 实现如下，首先确定插入节点 e 的前后指针，接着更新 e 的前后节点的 next 和 prev 指针。此外赋值所属 list 指针和增加 list 表示长度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// insert inserts e after at, increments l.len, and returns e.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">l</span> <span style="color:#000">*</span><span style="color:#000">List</span>) <span style="color:#000">insert</span>(<span style="color:#000">e</span>, <span style="color:#000">at</span> <span style="color:#000">*</span><span style="color:#000">Element</span>) <span style="color:#000">*</span><span style="color:#000">Element</span> {
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">prev</span> = <span style="color:#000">at</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">next</span> = <span style="color:#000">at</span>.<span style="color:#000">next</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">prev</span>.<span style="color:#000">next</span> = <span style="color:#000">e</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">next</span>.<span style="color:#000">prev</span> = <span style="color:#000">e</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">list</span> = <span style="color:#000">l</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">l</span>.<span style="color:#000">len</span><span style="color:#000">++</span>
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">return</span> <span style="color:#000">e</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>remove()</strong> 实现如下，更新前后节点的 next 和 prev 指针，然后释放当前节点的引用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// remove removes e from its list, decrements l.len
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">l</span> <span style="color:#000">*</span><span style="color:#000">List</span>) <span style="color:#000">remove</span>(<span style="color:#000">e</span> <span style="color:#000">*</span><span style="color:#000">Element</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">prev</span>.<span style="color:#000">next</span> = <span style="color:#000">e</span>.<span style="color:#000">next</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">next</span>.<span style="color:#000">prev</span> = <span style="color:#000">e</span>.<span style="color:#000">prev</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">next</span> = <span style="color:#a90d91">nil</span> <span style="color:#177500">// avoid memory leaks
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">e</span>.<span style="color:#000">prev</span> = <span style="color:#a90d91">nil</span> <span style="color:#177500">// avoid memory leaks
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">e</span>.<span style="color:#000">list</span> = <span style="color:#a90d91">nil</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">l</span>.<span style="color:#000">len</span><span style="color:#000">--</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>move()</strong> 的实现如下，首先判断是否需要移动，接着更新当前节点的前后节点指针，进行删除，最后更新插入位置的指针和插入位置前后节点的指针。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// move moves e to next to at.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">l</span> <span style="color:#000">*</span><span style="color:#000">List</span>) <span style="color:#000">move</span>(<span style="color:#000">e</span>, <span style="color:#000">at</span> <span style="color:#000">*</span><span style="color:#000">Element</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">e</span> <span style="color:#000">==</span> <span style="color:#000">at</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">return</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">prev</span>.<span style="color:#000">next</span> = <span style="color:#000">e</span>.<span style="color:#000">next</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">next</span>.<span style="color:#000">prev</span> = <span style="color:#000">e</span>.<span style="color:#000">prev</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">prev</span> = <span style="color:#000">at</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">next</span> = <span style="color:#000">at</span>.<span style="color:#000">next</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">prev</span>.<span style="color:#000">next</span> = <span style="color:#000">e</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">next</span>.<span style="color:#000">prev</span> = <span style="color:#000">e</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="ring">Ring</h3>
<p>是一个环形链表。环中的每一个元素由 Ring 构成。Ring 的组成如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// A Ring is an element of a circular list, or ring.
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// Rings do not have a beginning or end; a pointer to any ring element
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// serves as reference to the entire ring. Empty rings are represented
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// as nil Ring pointers. The zero value for a Ring is a one-element
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// ring with a nil Value.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">type</span> <span style="color:#000">Ring</span> <span style="color:#a90d91">struct</span> {
</span></span><span style="display:flex;"><span> <span style="color:#000">next</span>, <span style="color:#000">prev</span> <span style="color:#000">*</span><span style="color:#000">Ring</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">Value</span>      <span style="color:#000">any</span> <span style="color:#177500">// for use by client; untouched by this library
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>}
</span></span></code></pre></div><p>Ring 主要包括三类操作，1)、New() / Link() / Unlink() 等初始化及链接和断开环的操作。2)、Next() / Prev() / Move() 等移动节点的操作。3)、Do() 遍历环中节点的操作。</p>
<p><strong>New()</strong> 用来初始化环，New() 主要逻辑如下，首先判断长度是否大于零，然后初始化一个 Ring 指针，然后根据长度增加节点，最后链接头尾节点。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// New creates a ring of n elements.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> <span style="color:#000">New</span>(<span style="color:#000">n</span> <span style="color:#a90d91">int</span>) <span style="color:#000">*</span><span style="color:#000">Ring</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">n</span> <span style="color:#000">&lt;=</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">return</span> <span style="color:#a90d91">nil</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#000">r</span> <span style="color:#000">:=</span> <span style="color:#a90d91">new</span>(<span style="color:#000">Ring</span>)
</span></span><span style="display:flex;"><span> <span style="color:#000">p</span> <span style="color:#000">:=</span> <span style="color:#000">r</span>
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">for</span> <span style="color:#000">i</span> <span style="color:#000">:=</span> <span style="color:#1c01ce">1</span>; <span style="color:#000">i</span> &lt; <span style="color:#000">n</span>; <span style="color:#000">i</span><span style="color:#000">++</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">p</span>.<span style="color:#000">next</span> = <span style="color:#000">&amp;</span><span style="color:#000">Ring</span>{<span style="color:#000">prev</span>: <span style="color:#000">p</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#000">p</span> = <span style="color:#000">p</span>.<span style="color:#000">next</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#000">p</span>.<span style="color:#000">next</span> = <span style="color:#000">r</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">r</span>.<span style="color:#000">prev</span> = <span style="color:#000">p</span>
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">return</span> <span style="color:#000">r</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Link()</strong> 用于链接两个环，Link() 的实现如下，源码中强调了不能使用多重赋值，是因为多重赋值是不能保证赋值顺序的，而这里我们需要强调赋值的顺序。</p>
<p>首先获取当前节点 r 的下一个节点及目标节点 s 的最后一个节点，在节点 s 的头部进行链接，即 r.next = s 和 s.prev = r，接着在节点 s 的尾部进行链接，即 p.next() = n 和 n.prev = p。</p>
<p>如果 r 和 s 是同一个环中的节点，那么 r 和 s 中间的节点将会移除，r 和 s 链接在一起，剩下的部分链接在一起。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> (<span style="color:#000">r</span> <span style="color:#000">*</span><span style="color:#000">Ring</span>) <span style="color:#000">Link</span>(<span style="color:#000">s</span> <span style="color:#000">*</span><span style="color:#000">Ring</span>) <span style="color:#000">*</span><span style="color:#000">Ring</span> {
</span></span><span style="display:flex;"><span> <span style="color:#000">n</span> <span style="color:#000">:=</span> <span style="color:#000">r</span>.<span style="color:#000">Next</span>()
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">s</span> <span style="color:#000">!=</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">p</span> <span style="color:#000">:=</span> <span style="color:#000">s</span>.<span style="color:#000">Prev</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#177500">// Note: Cannot use multiple assignment because
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  <span style="color:#177500">// evaluation order of LHS is not specified.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  <span style="color:#000">r</span>.<span style="color:#000">next</span> = <span style="color:#000">s</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000">s</span>.<span style="color:#000">prev</span> = <span style="color:#000">r</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000">n</span>.<span style="color:#000">prev</span> = <span style="color:#000">p</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000">p</span>.<span style="color:#000">next</span> = <span style="color:#000">n</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">return</span> <span style="color:#000">n</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Next() / Move() / Prev()</strong> 逻辑相近，其实现如下。</p>
<p><em>其中 if r.next == nil 的判断可能是用户自己初始化的 Ring 结构体没有成环的检查 🤔️。</em></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// Next returns the next ring element. r must not be empty.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">r</span> <span style="color:#000">*</span><span style="color:#000">Ring</span>) <span style="color:#000">Next</span>() <span style="color:#000">*</span><span style="color:#000">Ring</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">r</span>.<span style="color:#000">next</span> <span style="color:#000">==</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">return</span> <span style="color:#000">r</span>.<span style="color:#000">init</span>()
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">return</span> <span style="color:#000">r</span>.<span style="color:#000">next</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#177500">// Prev returns the previous ring element. r must not be empty.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">r</span> <span style="color:#000">*</span><span style="color:#000">Ring</span>) <span style="color:#000">Prev</span>() <span style="color:#000">*</span><span style="color:#000">Ring</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">r</span>.<span style="color:#000">next</span> <span style="color:#000">==</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">return</span> <span style="color:#000">r</span>.<span style="color:#000">init</span>()
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">return</span> <span style="color:#000">r</span>.<span style="color:#000">prev</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#177500">// Move moves n % r.Len() elements backward (n &lt; 0) or forward (n &gt;= 0)
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// in the ring and returns that ring element. r must not be empty.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">r</span> <span style="color:#000">*</span><span style="color:#000">Ring</span>) <span style="color:#000">Move</span>(<span style="color:#000">n</span> <span style="color:#a90d91">int</span>) <span style="color:#000">*</span><span style="color:#000">Ring</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">r</span>.<span style="color:#000">next</span> <span style="color:#000">==</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">return</span> <span style="color:#000">r</span>.<span style="color:#000">init</span>()
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">switch</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">case</span> <span style="color:#000">n</span> &lt; <span style="color:#1c01ce">0</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">for</span> ; <span style="color:#000">n</span> &lt; <span style="color:#1c01ce">0</span>; <span style="color:#000">n</span><span style="color:#000">++</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#000">r</span> = <span style="color:#000">r</span>.<span style="color:#000">prev</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">case</span> <span style="color:#000">n</span> &gt; <span style="color:#1c01ce">0</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">for</span> ; <span style="color:#000">n</span> &gt; <span style="color:#1c01ce">0</span>; <span style="color:#000">n</span><span style="color:#000">--</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#000">r</span> = <span style="color:#000">r</span>.<span style="color:#000">next</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">return</span> <span style="color:#000">r</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Do()</strong> 函数逻辑即遍历环，并对每个节点应用 f()。<em>这种设计模式有一定的局限，如果 Do 能够传入可变参数列表，并将可变参数列表传入 f 中，这样可以将外部变量代入处理函数 f 中，这样在某些统计函数时带来便利性，如 Do(f(len), len) 这种模式。</em></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// Do calls function f on each element of the ring, in forward order.
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// The behavior of Do is undefined if f changes *r.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">r</span> <span style="color:#000">*</span><span style="color:#000">Ring</span>) <span style="color:#000">Do</span>(<span style="color:#000">f</span> <span style="color:#a90d91">func</span>(<span style="color:#000">any</span>)) {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">r</span> <span style="color:#000">!=</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">f</span>(<span style="color:#000">r</span>.<span style="color:#000">Value</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">for</span> <span style="color:#000">p</span> <span style="color:#000">:=</span> <span style="color:#000">r</span>.<span style="color:#000">Next</span>(); <span style="color:#000">p</span> <span style="color:#000">!=</span> <span style="color:#000">r</span>; <span style="color:#000">p</span> = <span style="color:#000">p</span>.<span style="color:#000">next</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#000">f</span>(<span style="color:#000">p</span>.<span style="color:#000">Value</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>相比于 List 的双向链表，Ring 是有限制的双向链表，Ring 有以下特点。</p>
<ol>
<li>无法在 O(1) 时间复杂度内确定环的长度。</li>
<li>不能直接调用 Insert、Remove 等传统链表操作。</li>
</ol>
<h3 id="heap">Heap</h3>
<blockquote>
<p>container/heap</p>
</blockquote>
<p>实现了堆的数据结构，这里采用 interface 的模式描述堆的特性，并不直接实现堆的容器。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">type</span> <span style="color:#000">Interface</span> <span style="color:#a90d91">interface</span> {
</span></span><span style="display:flex;"><span> <span style="color:#000">sort</span>.<span style="color:#000">Interface</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">Push</span>(<span style="color:#000">x</span> <span style="color:#000">any</span>) <span style="color:#177500">// add x as element Len()
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">Pop</span>() <span style="color:#000">any</span>   <span style="color:#177500">// remove and return element Len() - 1.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">type</span> <span style="color:#000">Interface</span> <span style="color:#a90d91">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">Len</span>() <span style="color:#a90d91">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">Less</span>(<span style="color:#000">i</span>, <span style="color:#000">j</span> <span style="color:#a90d91">int</span>) <span style="color:#a90d91">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">Swap</span>(<span style="color:#000">i</span>, <span style="color:#000">j</span> <span style="color:#a90d91">int</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Heap 的核心方法为 up() / down()，在《算法》一书中为 swim() / sink()，意为上浮和下沉。</p>
<p><strong>up()</strong> 的实现如下，首先 i := (j - 1) / 2 找到对应节点的父节点，<em>这里是从 0 开始计算节点</em>，接着判断节点是否为堆顶，判断是否需要进行交换，不满足条件退出循环，否则，交换父节点于子节点，并对父节点迭代操作。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">up</span>(<span style="color:#000">h</span> <span style="color:#000">Interface</span>, <span style="color:#000">j</span> <span style="color:#a90d91">int</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">for</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">i</span> <span style="color:#000">:=</span> (<span style="color:#000">j</span> <span style="color:#000">-</span> <span style="color:#1c01ce">1</span>) <span style="color:#000">/</span> <span style="color:#1c01ce">2</span> <span style="color:#177500">// parent
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  <span style="color:#a90d91">if</span> <span style="color:#000">i</span> <span style="color:#000">==</span> <span style="color:#000">j</span> <span style="color:#000">||</span> !<span style="color:#000">h</span>.<span style="color:#000">Less</span>(<span style="color:#000">j</span>, <span style="color:#000">i</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#a90d91">break</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000">h</span>.<span style="color:#000">Swap</span>(<span style="color:#000">i</span>, <span style="color:#000">j</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#000">j</span> = <span style="color:#000">i</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>down()</strong> 的实现如下，首先用 j1 := 2*i + 1计算对应子节点的索引，这里从 0 开始计算节点，并判断该索引是否超出长度 n，此外源码这里考虑到了可能溢出的问题，判断 j1 &lt; 0。</p>
<p>接着判断子节点中左节点和右节点的大小，选取更小者，最后判断更小者与父节点的大小关系，如果不满足交换则退出，否则交换子节点和父节点，并对子节点进行迭代。</p>
<p>最后返回结果时，根据初始索引和最后的索引值判断是否能够下沉。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">down</span>(<span style="color:#000">h</span> <span style="color:#000">Interface</span>, <span style="color:#000">i0</span>, <span style="color:#000">n</span> <span style="color:#a90d91">int</span>) <span style="color:#a90d91">bool</span> {
</span></span><span style="display:flex;"><span> <span style="color:#000">i</span> <span style="color:#000">:=</span> <span style="color:#000">i0</span>
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">for</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">j1</span> <span style="color:#000">:=</span> <span style="color:#1c01ce">2</span><span style="color:#000">*</span><span style="color:#000">i</span> <span style="color:#000">+</span> <span style="color:#1c01ce">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">if</span> <span style="color:#000">j1</span> <span style="color:#000">&gt;=</span> <span style="color:#000">n</span> <span style="color:#000">||</span> <span style="color:#000">j1</span> &lt; <span style="color:#1c01ce">0</span> { <span style="color:#177500">// j1 &lt; 0 after int overflow
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>   <span style="color:#a90d91">break</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000">j</span> <span style="color:#000">:=</span> <span style="color:#000">j1</span> <span style="color:#177500">// left child
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  <span style="color:#a90d91">if</span> <span style="color:#000">j2</span> <span style="color:#000">:=</span> <span style="color:#000">j1</span> <span style="color:#000">+</span> <span style="color:#1c01ce">1</span>; <span style="color:#000">j2</span> &lt; <span style="color:#000">n</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#000">h</span>.<span style="color:#000">Less</span>(<span style="color:#000">j2</span>, <span style="color:#000">j1</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#000">j</span> = <span style="color:#000">j2</span> <span style="color:#177500">// = 2*i + 2  // right child
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">if</span> !<span style="color:#000">h</span>.<span style="color:#000">Less</span>(<span style="color:#000">j</span>, <span style="color:#000">i</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#a90d91">break</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000">h</span>.<span style="color:#000">Swap</span>(<span style="color:#000">i</span>, <span style="color:#000">j</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#000">i</span> = <span style="color:#000">j</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">return</span> <span style="color:#000">i</span> &gt; <span style="color:#000">i0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Heap 根据 up() / down() 方法实现了其他暴露出来的 API。</p>
<p><strong>Init()</strong> 方法对堆进行初始化，<strong>Push() / Pop()</strong> 方法分别实现向堆中有序加入元素和弹出堆顶的操作，这两个操作依赖于 Interface 中实现的 Push 和 Pop。<strong>Remove()</strong> 方法将目标索引替换至队尾并重新有序化堆，最后调用 interface 中的 Pop 实现删除目标索引的元素。<strong>Fix()</strong> 方法用于堆指定元素重新有序化，这可以运用于直接修改堆中指定索引的元素后，调用 Fix 方法保证堆的有序化。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">Init</span>(<span style="color:#000">h</span> <span style="color:#000">Interface</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#177500">// heapify
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">n</span> <span style="color:#000">:=</span> <span style="color:#000">h</span>.<span style="color:#000">Len</span>()
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">for</span> <span style="color:#000">i</span> <span style="color:#000">:=</span> <span style="color:#000">n</span><span style="color:#000">/</span><span style="color:#1c01ce">2</span> <span style="color:#000">-</span> <span style="color:#1c01ce">1</span>; <span style="color:#000">i</span> <span style="color:#000">&gt;=</span> <span style="color:#1c01ce">0</span>; <span style="color:#000">i</span><span style="color:#000">--</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">down</span>(<span style="color:#000">h</span>, <span style="color:#000">i</span>, <span style="color:#000">n</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">Push</span>(<span style="color:#000">h</span> <span style="color:#000">Interface</span>, <span style="color:#000">x</span> <span style="color:#000">any</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#000">h</span>.<span style="color:#000">Push</span>(<span style="color:#000">x</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">up</span>(<span style="color:#000">h</span>, <span style="color:#000">h</span>.<span style="color:#000">Len</span>()<span style="color:#000">-</span><span style="color:#1c01ce">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">Pop</span>(<span style="color:#000">h</span> <span style="color:#000">Interface</span>) <span style="color:#000">any</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">n</span> <span style="color:#000">:=</span> <span style="color:#000">h</span>.<span style="color:#000">Len</span>() <span style="color:#000">-</span> <span style="color:#1c01ce">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">h</span>.<span style="color:#000">Swap</span>(<span style="color:#1c01ce">0</span>, <span style="color:#000">n</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">down</span>(<span style="color:#000">h</span>, <span style="color:#1c01ce">0</span>, <span style="color:#000">n</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">h</span>.<span style="color:#000">Pop</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">Remove</span>(<span style="color:#000">h</span> <span style="color:#000">Interface</span>, <span style="color:#000">i</span> <span style="color:#a90d91">int</span>) <span style="color:#000">any</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">n</span> <span style="color:#000">:=</span> <span style="color:#000">h</span>.<span style="color:#000">Len</span>() <span style="color:#000">-</span> <span style="color:#1c01ce">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">n</span> <span style="color:#000">!=</span> <span style="color:#000">i</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">h</span>.<span style="color:#000">Swap</span>(<span style="color:#000">i</span>, <span style="color:#000">n</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> !<span style="color:#000">down</span>(<span style="color:#000">h</span>, <span style="color:#000">i</span>, <span style="color:#000">n</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#000">up</span>(<span style="color:#000">h</span>, <span style="color:#000">i</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">h</span>.<span style="color:#000">Pop</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">Fix</span>(<span style="color:#000">h</span> <span style="color:#000">Interface</span>, <span style="color:#000">i</span> <span style="color:#a90d91">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> !<span style="color:#000">down</span>(<span style="color:#000">h</span>, <span style="color:#000">i</span>, <span style="color:#000">h</span>.<span style="color:#000">Len</span>()) {
</span></span><span style="display:flex;"><span>		<span style="color:#000">up</span>(<span style="color:#000">h</span>, <span style="color:#000">i</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="并发编程">并发编程</h2>
<h3 id="channel">Channel</h3>
<p>CSP(Communicating Sequential Processes) 顺序通信进程是一种并发编程模型，goroutine 和 channel 分别是 CSP 中的实体和消息媒介。</p>
<p>channel 的数据结构如下所示，在 Go 中由 hchan 数据结构所表示。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">type</span> <span style="color:#000">hchan</span> <span style="color:#a90d91">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">qcount</span>   <span style="color:#a90d91">uint</span>           <span style="color:#177500">// total data in the queue
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">dataqsiz</span> <span style="color:#a90d91">uint</span>           <span style="color:#177500">// size of the circular queue
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">buf</span>      <span style="color:#000">unsafe</span>.<span style="color:#000">Pointer</span> <span style="color:#177500">// points to an array of dataqsiz elements
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">elemsize</span> <span style="color:#a90d91">uint16</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">closed</span>   <span style="color:#a90d91">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">elemtype</span> <span style="color:#000">*</span><span style="color:#000">_type</span> <span style="color:#177500">// element type
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">sendx</span>    <span style="color:#a90d91">uint</span>   <span style="color:#177500">// send index
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">recvx</span>    <span style="color:#a90d91">uint</span>   <span style="color:#177500">// receive index
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">recvq</span>    <span style="color:#000">waitq</span>  <span style="color:#177500">// list of recv waiters
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">sendq</span>    <span style="color:#000">waitq</span>  <span style="color:#177500">// list of send waiters
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// lock protects all fields in hchan, as well as several
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// fields in sudogs blocked on this channel.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">//
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// Do not change another G&#39;s status while holding this lock
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// (in particular, do not ready a G), as this can deadlock
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// with stack shrinking.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">lock</span> <span style="color:#000">mutex</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>buf 是 channel 中的缓冲区，sendx 与 recvx 分别表示发送端和接受端在 buf 中所在的位置。channel 的缓冲区即一个由数组模拟的环形缓冲区。</p>
<p>recvq 和 sendq 分别表示 channel 上接收者和发送者的等待队列，当 channel 中的缓存区为空（满）时，接收者（发送者）将阻塞，channel 将阻塞的 goroutine 加入到 waitq 链表中进行管理。</p>
<p><strong><strong>简而言之</strong></strong>，Channel 是一个由环形缓冲数组、消费者队列、生产者队列组成的通信结构。</p>
<p><strong>当向 channel 发送数据时</strong>，分为以下三种情况：</p>
<ol>
<li>当 channel 的 recvq 等待队列中存在接收者时，直接通过 DirectSend 方法将发送的消息复制到 a := &lt;- ch 中的变量 a 中，同时唤醒对应的接收者 goroutine，将其加入到 runnext 队列中，在下次调度时运行 goroutine。</li>
<li>当 channel 的缓冲区不为空时，将发送消息拷贝到缓冲区中。</li>
<li>当 channel 的缓冲区满时，将发送者加入到 sendq 等待队列中，并阻塞当前的 goroutine，等待接收者接收消息后唤醒。</li>
</ol>
<p><strong>当从 channel 中读取数据时</strong>，与向 channel 中发送数据相同，分为三种情况：</p>
<ol>
<li>当 channel 的 sendq 等待队列中存在发送者时且缓冲区中存在数据，则从缓冲区中获取数据，并唤醒 sendq 等待队列中的一个发送者，将数据追加到缓冲区中。如果缓冲区中没有数据，则直接将发送消息复制到对应的接收变量中。</li>
<li>当 channel 的缓冲区不为空时，直接获取缓冲区中的数据。</li>
<li>当 channel 为空时，将当前 goroutine 添加到 recvq 等待队列中，然后阻塞当前 goroutine。</li>
</ol>
<p><strong>channel 主要涉及创建、发送和接收三个操作</strong>：</p>
<ul>
<li>
<p>func <strong>makechan</strong>(t *chantype, size int) *hchan {}</p>
<p>首先计算创建 channel 需要的内存大小，接着根据内存大小、存储的内容是否包括指针选择申请内存的方式，最后初始化相关变量后返回 <code>*hchan</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">makechan</span>(<span style="color:#000">t</span> <span style="color:#000">*</span><span style="color:#000">chantype</span>, <span style="color:#000">size</span> <span style="color:#a90d91">int</span>) <span style="color:#000">*</span><span style="color:#000">hchan</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">elem</span> <span style="color:#000">:=</span> <span style="color:#000">t</span>.<span style="color:#000">elem</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// compiler checks this but be safe.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">if</span> <span style="color:#000">elem</span>.<span style="color:#000">size</span> <span style="color:#000">&gt;=</span> <span style="color:#1c01ce">1</span><span style="color:#000">&lt;&lt;</span><span style="color:#1c01ce">16</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">throw</span>(<span style="color:#c41a16">&#34;makechan: invalid channel element type&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">hchanSize</span><span style="color:#000">%</span><span style="color:#000">maxAlign</span> <span style="color:#000">!=</span> <span style="color:#1c01ce">0</span> <span style="color:#000">||</span> <span style="color:#000">elem</span>.<span style="color:#000">align</span> &gt; <span style="color:#000">maxAlign</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">throw</span>(<span style="color:#c41a16">&#34;makechan: bad alignment&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">mem</span>, <span style="color:#000">overflow</span> <span style="color:#000">:=</span> <span style="color:#000">math</span>.<span style="color:#000">MulUintptr</span>(<span style="color:#000">elem</span>.<span style="color:#000">size</span>, <span style="color:#a90d91">uintptr</span>(<span style="color:#000">size</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">overflow</span> <span style="color:#000">||</span> <span style="color:#000">mem</span> &gt; <span style="color:#000">maxAlloc</span><span style="color:#000">-</span><span style="color:#000">hchanSize</span> <span style="color:#000">||</span> <span style="color:#000">size</span> &lt; <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">panic</span>(<span style="color:#000">plainError</span>(<span style="color:#c41a16">&#34;makechan: size out of range&#34;</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// buf points into the same allocation, elemtype is persistent.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">var</span> <span style="color:#000">c</span> <span style="color:#000">*</span><span style="color:#000">hchan</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">switch</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">case</span> <span style="color:#000">mem</span> <span style="color:#000">==</span> <span style="color:#1c01ce">0</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// Queue or element size is zero.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#000">c</span> = (<span style="color:#000">*</span><span style="color:#000">hchan</span>)(<span style="color:#000">mallocgc</span>(<span style="color:#000">hchanSize</span>, <span style="color:#a90d91">nil</span>, <span style="color:#a90d91">true</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// Race detector uses this location for synchronization.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#000">c</span>.<span style="color:#000">buf</span> = <span style="color:#000">c</span>.<span style="color:#000">raceaddr</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">case</span> <span style="color:#000">elem</span>.<span style="color:#000">ptrdata</span> <span style="color:#000">==</span> <span style="color:#1c01ce">0</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// Elements do not contain pointers.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#177500">// Allocate hchan and buf in one call.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#000">c</span> = (<span style="color:#000">*</span><span style="color:#000">hchan</span>)(<span style="color:#000">mallocgc</span>(<span style="color:#000">hchanSize</span><span style="color:#000">+</span><span style="color:#000">mem</span>, <span style="color:#a90d91">nil</span>, <span style="color:#a90d91">true</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#000">c</span>.<span style="color:#000">buf</span> = <span style="color:#000">add</span>(<span style="color:#000">unsafe</span>.<span style="color:#000">Pointer</span>(<span style="color:#000">c</span>), <span style="color:#000">hchanSize</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">default</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// Elements contain pointers.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#000">c</span> = <span style="color:#a90d91">new</span>(<span style="color:#000">hchan</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#000">c</span>.<span style="color:#000">buf</span> = <span style="color:#000">mallocgc</span>(<span style="color:#000">mem</span>, <span style="color:#000">elem</span>, <span style="color:#a90d91">true</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">c</span>.<span style="color:#000">elemsize</span> = <span style="color:#a90d91">uint16</span>(<span style="color:#000">elem</span>.<span style="color:#000">size</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">c</span>.<span style="color:#000">elemtype</span> = <span style="color:#000">elem</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">c</span>.<span style="color:#000">dataqsiz</span> = <span style="color:#a90d91">uint</span>(<span style="color:#000">size</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">lockInit</span>(<span style="color:#000">&amp;</span><span style="color:#000">c</span>.<span style="color:#000">lock</span>, <span style="color:#000">lockRankHchan</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">debugChan</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">print</span>(<span style="color:#c41a16">&#34;makechan: chan=&#34;</span>, <span style="color:#000">c</span>, <span style="color:#c41a16">&#34;; elemsize=&#34;</span>, <span style="color:#000">elem</span>.<span style="color:#000">size</span>, <span style="color:#c41a16">&#34;; dataqsiz=&#34;</span>, <span style="color:#000">size</span>, <span style="color:#c41a16">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">c</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>func <strong>chansend</strong>(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {}</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">chansend</span>(<span style="color:#000">c</span> <span style="color:#000">*</span><span style="color:#000">hchan</span>, <span style="color:#000">ep</span> <span style="color:#000">unsafe</span>.<span style="color:#000">Pointer</span>, <span style="color:#000">block</span> <span style="color:#a90d91">bool</span>, <span style="color:#000">callerpc</span> <span style="color:#a90d91">uintptr</span>) <span style="color:#a90d91">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">c</span> <span style="color:#000">==</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> !<span style="color:#000">block</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a90d91">return</span> <span style="color:#a90d91">false</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#000">gopark</span>(<span style="color:#a90d91">nil</span>, <span style="color:#a90d91">nil</span>, <span style="color:#000">waitReasonChanSendNilChan</span>, <span style="color:#000">traceEvGoStop</span>, <span style="color:#1c01ce">2</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#000">throw</span>(<span style="color:#c41a16">&#34;unreachable&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">debugChan</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">print</span>(<span style="color:#c41a16">&#34;chansend: chan=&#34;</span>, <span style="color:#000">c</span>, <span style="color:#c41a16">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">raceenabled</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">racereadpc</span>(<span style="color:#000">c</span>.<span style="color:#000">raceaddr</span>(), <span style="color:#000">callerpc</span>, <span style="color:#000">abi</span>.<span style="color:#000">FuncPCABIInternal</span>(<span style="color:#000">chansend</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// Fast path: check for failed non-blocking operation without acquiring the lock.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">//
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// After observing that the channel is not closed, we observe that the channel is
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// not ready for sending. Each of these observations is a single word-sized read
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// (first c.closed and second full()).
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// Because a closed channel cannot transition from &#39;ready for sending&#39; to
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// &#39;not ready for sending&#39;, even if the channel is closed between the two observations,
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// they imply a moment between the two when the channel was both not yet closed
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// and not ready for sending. We behave as if we observed the channel at that moment,
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// and report that the send cannot proceed.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">//
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// It is okay if the reads are reordered here: if we observe that the channel is not
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// ready for sending and then observe that it is not closed, that implies that the
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// channel wasn&#39;t closed during the first observation. However, nothing here
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// guarantees forward progress. We rely on the side effects of lock release in
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// chanrecv() and closechan() to update this thread&#39;s view of c.closed and full().
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">if</span> !<span style="color:#000">block</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#000">c</span>.<span style="color:#000">closed</span> <span style="color:#000">==</span> <span style="color:#1c01ce">0</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#000">full</span>(<span style="color:#000">c</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">return</span> <span style="color:#a90d91">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">var</span> <span style="color:#000">t0</span> <span style="color:#a90d91">int64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">blockprofilerate</span> &gt; <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">t0</span> = <span style="color:#000">cputicks</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">lock</span>(<span style="color:#000">&amp;</span><span style="color:#000">c</span>.<span style="color:#000">lock</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">c</span>.<span style="color:#000">closed</span> <span style="color:#000">!=</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">unlock</span>(<span style="color:#000">&amp;</span><span style="color:#000">c</span>.<span style="color:#000">lock</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">panic</span>(<span style="color:#000">plainError</span>(<span style="color:#c41a16">&#34;send on closed channel&#34;</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">sg</span> <span style="color:#000">:=</span> <span style="color:#000">c</span>.<span style="color:#000">recvq</span>.<span style="color:#000">dequeue</span>(); <span style="color:#000">sg</span> <span style="color:#000">!=</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// Found a waiting receiver. We pass the value we want to send
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#177500">// directly to the receiver, bypassing the channel buffer (if any).
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#000">send</span>(<span style="color:#000">c</span>, <span style="color:#000">sg</span>, <span style="color:#000">ep</span>, <span style="color:#a90d91">func</span>() { <span style="color:#000">unlock</span>(<span style="color:#000">&amp;</span><span style="color:#000">c</span>.<span style="color:#000">lock</span>) }, <span style="color:#1c01ce">3</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">return</span> <span style="color:#a90d91">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">c</span>.<span style="color:#000">qcount</span> &lt; <span style="color:#000">c</span>.<span style="color:#000">dataqsiz</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// Space is available in the channel buffer. Enqueue the element to send.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#000">qp</span> <span style="color:#000">:=</span> <span style="color:#000">chanbuf</span>(<span style="color:#000">c</span>, <span style="color:#000">c</span>.<span style="color:#000">sendx</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">raceenabled</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#000">racenotify</span>(<span style="color:#000">c</span>, <span style="color:#000">c</span>.<span style="color:#000">sendx</span>, <span style="color:#a90d91">nil</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#000">typedmemmove</span>(<span style="color:#000">c</span>.<span style="color:#000">elemtype</span>, <span style="color:#000">qp</span>, <span style="color:#000">ep</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#000">c</span>.<span style="color:#000">sendx</span><span style="color:#000">++</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">c</span>.<span style="color:#000">sendx</span> <span style="color:#000">==</span> <span style="color:#000">c</span>.<span style="color:#000">dataqsiz</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#000">c</span>.<span style="color:#000">sendx</span> = <span style="color:#1c01ce">0</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#000">c</span>.<span style="color:#000">qcount</span><span style="color:#000">++</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">unlock</span>(<span style="color:#000">&amp;</span><span style="color:#000">c</span>.<span style="color:#000">lock</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">return</span> <span style="color:#a90d91">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> !<span style="color:#000">block</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">unlock</span>(<span style="color:#000">&amp;</span><span style="color:#000">c</span>.<span style="color:#000">lock</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">return</span> <span style="color:#a90d91">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// Block on the channel. Some receiver will complete our operation for us.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">gp</span> <span style="color:#000">:=</span> <span style="color:#000">getg</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#000">mysg</span> <span style="color:#000">:=</span> <span style="color:#000">acquireSudog</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#000">mysg</span>.<span style="color:#000">releasetime</span> = <span style="color:#1c01ce">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">t0</span> <span style="color:#000">!=</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">mysg</span>.<span style="color:#000">releasetime</span> = <span style="color:#000">-</span><span style="color:#1c01ce">1</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// No stack splits between assigning elem and enqueuing mysg
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// on gp.waiting where copystack can find it.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">mysg</span>.<span style="color:#000">elem</span> = <span style="color:#000">ep</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">mysg</span>.<span style="color:#000">waitlink</span> = <span style="color:#a90d91">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">mysg</span>.<span style="color:#000">g</span> = <span style="color:#000">gp</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">mysg</span>.<span style="color:#000">isSelect</span> = <span style="color:#a90d91">false</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">mysg</span>.<span style="color:#000">c</span> = <span style="color:#000">c</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">gp</span>.<span style="color:#000">waiting</span> = <span style="color:#000">mysg</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">gp</span>.<span style="color:#000">param</span> = <span style="color:#a90d91">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">c</span>.<span style="color:#000">sendq</span>.<span style="color:#000">enqueue</span>(<span style="color:#000">mysg</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// Signal to anyone trying to shrink our stack that we&#39;re about
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// to park on a channel. The window between when this G&#39;s status
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// changes and when we set gp.activeStackChans is not safe for
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// stack shrinking.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">gp</span>.<span style="color:#000">parkingOnChan</span>.<span style="color:#000">Store</span>(<span style="color:#a90d91">true</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">gopark</span>(<span style="color:#000">chanparkcommit</span>, <span style="color:#000">unsafe</span>.<span style="color:#000">Pointer</span>(<span style="color:#000">&amp;</span><span style="color:#000">c</span>.<span style="color:#000">lock</span>), <span style="color:#000">waitReasonChanSend</span>, <span style="color:#000">traceEvGoBlockSend</span>, <span style="color:#1c01ce">2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// Ensure the value being sent is kept alive until the
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// receiver copies it out. The sudog has a pointer to the
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// stack object, but sudogs aren&#39;t considered as roots of the
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// stack tracer.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">KeepAlive</span>(<span style="color:#000">ep</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// someone woke us up.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">if</span> <span style="color:#000">mysg</span> <span style="color:#000">!=</span> <span style="color:#000">gp</span>.<span style="color:#000">waiting</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">throw</span>(<span style="color:#c41a16">&#34;G waiting list is corrupted&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#000">gp</span>.<span style="color:#000">waiting</span> = <span style="color:#a90d91">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">gp</span>.<span style="color:#000">activeStackChans</span> = <span style="color:#a90d91">false</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">closed</span> <span style="color:#000">:=</span> !<span style="color:#000">mysg</span>.<span style="color:#000">success</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">gp</span>.<span style="color:#000">param</span> = <span style="color:#a90d91">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">mysg</span>.<span style="color:#000">releasetime</span> &gt; <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">blockevent</span>(<span style="color:#000">mysg</span>.<span style="color:#000">releasetime</span><span style="color:#000">-</span><span style="color:#000">t0</span>, <span style="color:#1c01ce">2</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#000">mysg</span>.<span style="color:#000">c</span> = <span style="color:#a90d91">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">releaseSudog</span>(<span style="color:#000">mysg</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">closed</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">c</span>.<span style="color:#000">closed</span> <span style="color:#000">==</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#000">throw</span>(<span style="color:#c41a16">&#34;chansend: spurious wakeup&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">panic</span>(<span style="color:#000">plainError</span>(<span style="color:#c41a16">&#34;send on closed channel&#34;</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#a90d91">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>func <strong>chanrecv</strong>(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {}</p>
</li>
</ul>
<hr>
<p>⚠️值得注意：</p>
<ul>
<li>
<p><strong>关闭 channel 时</strong>，会将 recvq 和 sendq 中的等待 goroutine 唤醒，由 GMP 调度器负责调度等待的 goroutine。<strong>从关闭的 goroutine 中读取数据时</strong>，如果 channel 缓冲区中仍有数据，将获取到缓冲区中的数据，如果 channel 缓冲区为空，将得到零值，<strong>需要注意的是，即使此时原来仍有阻塞的发送者，并不能获取到这次发送的消息</strong>，如下代码所示。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">goroutineExample</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">println</span>(<span style="color:#c41a16">&#34;goroutine example&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">ch</span> <span style="color:#000">:=</span> <span style="color:#a90d91">make</span>(<span style="color:#a90d91">chan</span> <span style="color:#a90d91">int</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">go</span> <span style="color:#a90d91">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#000">ch</span> <span style="color:#000">&lt;-</span> <span style="color:#1c01ce">1</span>
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#000">time</span>.<span style="color:#000">Sleep</span>(<span style="color:#1c01ce">1000</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">close</span>(<span style="color:#000">ch</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">v</span> <span style="color:#000">:=</span> <span style="color:#000">&lt;-</span><span style="color:#000">ch</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">println</span>(<span style="color:#c41a16">&#34;read ch: &#34;</span>, <span style="color:#000">v</span>) <span style="color:#177500">// v is 0 not 1
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>}
</span></span></code></pre></div><p><strong>向关闭的 channel 中发送消息</strong>，将导致 panic。</p>
</li>
<li>
<p>向 nil 的 channel 中发送数据将导致 goroutine 永久阻塞，而不是 panic!!!</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">TestChannel</span>(<span style="color:#000">t</span> <span style="color:#000">*</span><span style="color:#000">testing</span>.<span style="color:#000">T</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#000">t</span>.<span style="color:#000">Log</span>(<span style="color:#c41a16">&#34;block channel forever!!!&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">var</span> <span style="color:#000">blockCh</span> <span style="color:#a90d91">chan</span> <span style="color:#a90d91">interface</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#000">blockCh</span> <span style="color:#000">&lt;-</span> <span style="color:#a90d91">struct</span>{}{}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h3 id="go-sync">Go Sync</h3>
<h3 id="pool">Pool</h3>
<p>通过 Put() / Get() 管理缓存对象，使用 New() 生成默认缓存对象，从而减少 GC 压力，数据结构方面涉及 <strong>Dequeue、RingBuffer</strong> 等方面，难点涉及 <strong>P 的 LocalPool、Pin 等关于调度器内存结构及调度器抢占</strong>等内容。</p>
<p>下面是 Gin 中的实践：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// ServeHTTP conforms to the http.Handler interface.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">engine</span> <span style="color:#000">*</span><span style="color:#000">Engine</span>) <span style="color:#000">ServeHTTP</span>(<span style="color:#000">w</span> <span style="color:#000">http</span>.<span style="color:#000">ResponseWriter</span>, <span style="color:#000">req</span> <span style="color:#000">*</span><span style="color:#000">http</span>.<span style="color:#000">Request</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#000">c</span> <span style="color:#000">:=</span> <span style="color:#000">engine</span>.<span style="color:#000">pool</span>.<span style="color:#000">Get</span>().(<span style="color:#000">*</span><span style="color:#000">Context</span>) <span style="color:#177500">// get
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">c</span>.<span style="color:#000">writermem</span>.<span style="color:#000">reset</span>(<span style="color:#000">w</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">c</span>.<span style="color:#000">Request</span> = <span style="color:#000">req</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">c</span>.<span style="color:#000">reset</span>() <span style="color:#177500">// clean !!!
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">engine</span>.<span style="color:#000">handleHTTPRequest</span>(<span style="color:#000">c</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">engine</span>.<span style="color:#000">pool</span>.<span style="color:#000">Put</span>(<span style="color:#000">c</span>) <span style="color:#177500">// put
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>}
</span></span></code></pre></div><p>在实现上，调用 Put 和 Get 前，先调用 pin( ) 方法锁定当前的 goroutine，使其不能被抢占，然后将变量添加到 PoolChain 链表中，或从链表中获取对应的缓存对象。最后调用 runtime_procUnpin( ) 接触锁定。</p>
<h3 id="mutex--rwmutex">Mutex &amp; RWMutex</h3>
<blockquote>
<p>Golang sync.Mutex分析</p>
<p><a href="https://seekload.net/2021/12/12/sync-mutex.html">Go并发原语-mutex源码解析</a></p>
</blockquote>
<p>Mutex 通过 Lock() 和 UnLock() 两个方法实现并发原语，Mutex 的结构为包括 state 和 sema 两个变量。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">type</span> <span style="color:#000">Mutex</span> <span style="color:#a90d91">struct</span> {
</span></span><span style="display:flex;"><span> <span style="color:#000">state</span> <span style="color:#a90d91">int32</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">sema</span>  <span style="color:#a90d91">uint32</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在加锁和解锁的主要对 state 变量进行操作，state 变量结构如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000">mutexLocked</span> = <span style="color:#1c01ce">1</span> <span style="color:#000">&lt;&lt;</span> <span style="color:#a90d91">iota</span> <span style="color:#177500">// mutex is locked 1 表示锁已经被占用
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#000">mutexWoken</span> <span style="color:#177500">// 1 表示目前有唤醒的协程正在竞争锁，不需要再唤醒等待的协程
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#000">mutexStarving</span> <span style="color:#177500">// 1 表示当前的锁处于饥饿状态
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#000">mutexWaiterShift</span> = <span style="color:#a90d91">iota</span> <span style="color:#177500">// 3，占3 至 31 位，代表等待该锁的 goroutine 数量，
</span></span></span></code></pre></div><p>Lock( ) 过程如下，首先通过 CAS 快速判断是否能够获取得到锁，如果失败则通过 m.lockSlow( ) 方法通过自旋和信号量等方式获取得到锁。在 lockSlow( ) 方法中涉及 wake  变量及饥饿模型等锁的设计。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> (<span style="color:#000">m</span> <span style="color:#000">*</span><span style="color:#000">Mutex</span>) <span style="color:#000">Lock</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// Fast path: grab unlocked mutex.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">if</span> <span style="color:#000">atomic</span>.<span style="color:#000">CompareAndSwapInt32</span>(<span style="color:#000">&amp;</span><span style="color:#000">m</span>.<span style="color:#000">state</span>, <span style="color:#1c01ce">0</span>, <span style="color:#000">mutexLocked</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">race</span>.<span style="color:#000">Enabled</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#000">race</span>.<span style="color:#000">Acquire</span>(<span style="color:#000">unsafe</span>.<span style="color:#000">Pointer</span>(<span style="color:#000">m</span>))
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// Slow path (outlined so that the fast path can be inlined)
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">m</span>.<span style="color:#000">lockSlow</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>UnLock( ) 方法与 Lock( ) 方法类似，</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> (<span style="color:#000">m</span> <span style="color:#000">*</span><span style="color:#000">Mutex</span>) <span style="color:#000">Unlock</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">race</span>.<span style="color:#000">Enabled</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">_</span> = <span style="color:#000">m</span>.<span style="color:#000">state</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">race</span>.<span style="color:#000">Release</span>(<span style="color:#000">unsafe</span>.<span style="color:#000">Pointer</span>(<span style="color:#000">m</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// Fast path: drop lock bit.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">new</span> <span style="color:#000">:=</span> <span style="color:#000">atomic</span>.<span style="color:#000">AddInt32</span>(<span style="color:#000">&amp;</span><span style="color:#000">m</span>.<span style="color:#000">state</span>, <span style="color:#000">-</span><span style="color:#000">mutexLocked</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">new</span> <span style="color:#000">!=</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// Outlined slow path to allow inlining the fast path.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#177500">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#000">m</span>.<span style="color:#000">unlockSlow</span>(<span style="color:#000">new</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="cond">Cond</h3>
<blockquote>
<p>Golang sync.Cond 条件变量源码分析</p>
</blockquote>
<p>通过调用 Wait( ) / Signal( ) / Broadcast( ) 等方法来实现 goroutine 等待某一事件发生的并发同步。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000">cd</span> <span style="color:#000">:=</span> <span style="color:#000">sync</span>.<span style="color:#000">NewCond</span>(<span style="color:#000">&amp;</span><span style="color:#000">sync</span>.<span style="color:#000">Mutex</span>{})
</span></span><span style="display:flex;"><span><span style="color:#a90d91">for</span> <span style="color:#a90d91">range</span> []<span style="color:#a90d91">int</span>{<span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">2</span>, <span style="color:#1c01ce">3</span>} {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">go</span> <span style="color:#a90d91">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#000">cd</span>.<span style="color:#000">L</span>.<span style="color:#000">Lock</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#000">cd</span>.<span style="color:#000">Wait</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#000">cd</span>.<span style="color:#000">L</span>.<span style="color:#000">Unlock</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">println</span>(<span style="color:#c41a16">&#34;go&#34;</span>)
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#000">time</span>.<span style="color:#000">Sleep</span>(<span style="color:#1c01ce">1e6</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000">cd</span>.<span style="color:#000">L</span>.<span style="color:#000">Lock</span>()
</span></span><span style="display:flex;"><span><span style="color:#a90d91">println</span>(<span style="color:#c41a16">&#34;signal&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#000">cd</span>.<span style="color:#000">Signal</span>()
</span></span><span style="display:flex;"><span><span style="color:#000">cd</span>.<span style="color:#000">L</span>.<span style="color:#000">Unlock</span>()
</span></span><span style="display:flex;"><span><span style="color:#000">time</span>.<span style="color:#000">Sleep</span>(<span style="color:#1c01ce">1e6</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">println</span>(<span style="color:#c41a16">&#34;broadcast&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#000">cd</span>.<span style="color:#000">L</span>.<span style="color:#000">Lock</span>()
</span></span><span style="display:flex;"><span><span style="color:#000">cd</span>.<span style="color:#000">Broadcast</span>()
</span></span><span style="display:flex;"><span><span style="color:#000">cd</span>.<span style="color:#000">L</span>.<span style="color:#000">Unlock</span>()
</span></span><span style="display:flex;"><span><span style="color:#000">time</span>.<span style="color:#000">Sleep</span>(<span style="color:#1c01ce">1e6</span>)
</span></span></code></pre></div><p>Wait( ) 方法将当前 goroutine 添加到唤醒队列并解锁，然后让出 CPU 等待调度器的调度。Signal/Broadcast 方法会唤醒队列中的一个或全部等待协程。</p>
<h3 id="once">Once</h3>
<p>提供了只运行一次指定函数的保证。下面是实现逻辑：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> (<span style="color:#000">o</span> <span style="color:#000">*</span><span style="color:#000">Once</span>) <span style="color:#000">Do</span>(<span style="color:#000">f</span> <span style="color:#a90d91">func</span>()) {
</span></span><span style="display:flex;"><span> <span style="color:#177500">// Note: Here is an incorrect implementation of Do:
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">//
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// if atomic.CompareAndSwapUint32(&amp;o.done, 0, 1) {
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">//  f()
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// }
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">//
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// Do guarantees that when it returns, f has finished.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// This implementation would not implement that guarantee:
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// given two simultaneous calls, the winner of the cas would
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// call f, and the second would return immediately, without
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// waiting for the first&#39;s call to f to complete.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// This is why the slow path falls back to a mutex, and why
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// the atomic.StoreUint32 must be delayed until after f returns.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">atomic</span>.<span style="color:#000">LoadUint32</span>(<span style="color:#000">&amp;</span><span style="color:#000">o</span>.<span style="color:#000">done</span>) <span style="color:#000">==</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#177500">// Outlined slow-path to allow inlining of the fast-path.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  <span style="color:#000">o</span>.<span style="color:#000">doSlow</span>(<span style="color:#000">f</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> (<span style="color:#000">o</span> <span style="color:#000">*</span><span style="color:#000">Once</span>) <span style="color:#000">doSlow</span>(<span style="color:#000">f</span> <span style="color:#a90d91">func</span>()) {
</span></span><span style="display:flex;"><span> <span style="color:#000">o</span>.<span style="color:#000">m</span>.<span style="color:#000">Lock</span>()
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">defer</span> <span style="color:#000">o</span>.<span style="color:#000">m</span>.<span style="color:#000">Unlock</span>()
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">o</span>.<span style="color:#000">done</span> <span style="color:#000">==</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">defer</span> <span style="color:#000">atomic</span>.<span style="color:#000">StoreUint32</span>(<span style="color:#000">&amp;</span><span style="color:#000">o</span>.<span style="color:#000">done</span>, <span style="color:#1c01ce">1</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#000">f</span>()
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中 comment 也指出，不能简单的通过 CAS 操作保证 f( ) 执行一次，因为 CAS 操作不能保证 f( ) 返回，两个线程同时进行 CAS 第二个线程可能在第一个线程 f( ) 调用未返回之前返回。而通过 mutex 能够保证所有线程都在 f( ) 完成一次且仅完成一次的情况下返回，在未返回之前阻塞。</p>
<h3 id="waitgroup">WaitGroup</h3>
<blockquote>
<p>Golang WaitGroup 原理深度剖析</p>
<p><a href="https://juejin.cn/post/7102881182294999047">Golang | 详解sync.WaitGroup</a></p>
</blockquote>
<p>通过 Add() / Done() / Wait() 接口实现某线程等待其他多线程完成任务的并发同步。</p>
<p>主要结构体如下所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">type</span> <span style="color:#000">WaitGroup</span> <span style="color:#a90d91">struct</span> {
</span></span><span style="display:flex;"><span> <span style="color:#000">noCopy</span> <span style="color:#000">noCopy</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#177500">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// 64-bit atomic operations require 64-bit alignment, but 32-bit
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// compilers only guarantee that 64-bit fields are 32-bit aligned.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// For this reason on 32 bit architectures we need to check in state()
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// if state1 is aligned or not, and dynamically &#34;swap&#34; the field order if
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// needed.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">state1</span> <span style="color:#a90d91">uint64</span> <span style="color:#177500">// 高 32 位存储 counter 数目，低 32 位存储 waiter 数目。
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">state2</span> <span style="color:#a90d91">uint32</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中 Done() 通过调用 Add(1) 实现</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// Done decrements the WaitGroup counter by one.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">wg</span> <span style="color:#000">*</span><span style="color:#000">WaitGroup</span>) <span style="color:#000">Done</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#000">wg</span>.<span style="color:#000">Add</span>(<span style="color:#000">-</span><span style="color:#1c01ce">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Add() 主要逻辑如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> (<span style="color:#000">wg</span> <span style="color:#000">*</span><span style="color:#000">WaitGroup</span>) <span style="color:#000">Add</span>(<span style="color:#000">delta</span> <span style="color:#a90d91">int</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#000">statep</span>, <span style="color:#000">semap</span> <span style="color:#000">:=</span> <span style="color:#000">wg</span>.<span style="color:#000">state</span>()
</span></span><span style="display:flex;"><span> <span style="color:#000">state</span> <span style="color:#000">:=</span> <span style="color:#000">atomic</span>.<span style="color:#000">AddUint64</span>(<span style="color:#000">statep</span>, <span style="color:#a90d91">uint64</span>(<span style="color:#000">delta</span>)<span style="color:#000">&lt;&lt;</span><span style="color:#1c01ce">32</span>)
</span></span><span style="display:flex;"><span> <span style="color:#000">v</span> <span style="color:#000">:=</span> <span style="color:#a90d91">int32</span>(<span style="color:#000">state</span> <span style="color:#000">&gt;&gt;</span> <span style="color:#1c01ce">32</span>)
</span></span><span style="display:flex;"><span> <span style="color:#000">w</span> <span style="color:#000">:=</span> <span style="color:#a90d91">uint32</span>(<span style="color:#000">state</span>)
</span></span><span style="display:flex;"><span> <span style="color:#177500">// 如果 v(counter) 大于零并且 w(waiter) 等于零
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// 说明没有阻塞的 goroutine，此时直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#a90d91">if</span> <span style="color:#000">v</span> &gt; <span style="color:#1c01ce">0</span> <span style="color:#000">||</span> <span style="color:#000">w</span> <span style="color:#000">==</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#a90d91">return</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#177500">// counter 等于零此时，需要唤醒所有阻塞的 goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// Reset waiters count to 0.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">*</span><span style="color:#000">statep</span> = <span style="color:#1c01ce">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#177500">// 唤醒所有阻塞的 goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#a90d91">for</span> ; <span style="color:#000">w</span> <span style="color:#000">!=</span> <span style="color:#1c01ce">0</span>; <span style="color:#000">w</span><span style="color:#000">--</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">runtime_Semrelease</span>(<span style="color:#000">semap</span>, <span style="color:#a90d91">false</span>, <span style="color:#1c01ce">0</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Wait() 逻辑如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> (<span style="color:#000">wg</span> <span style="color:#000">*</span><span style="color:#000">WaitGroup</span>) <span style="color:#000">Wait</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#000">statep</span>, <span style="color:#000">semap</span> <span style="color:#000">:=</span> <span style="color:#000">wg</span>.<span style="color:#000">state</span>()
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">for</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">state</span> <span style="color:#000">:=</span> <span style="color:#000">atomic</span>.<span style="color:#000">LoadUint64</span>(<span style="color:#000">statep</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#000">v</span> <span style="color:#000">:=</span> <span style="color:#a90d91">int32</span>(<span style="color:#000">state</span> <span style="color:#000">&gt;&gt;</span> <span style="color:#1c01ce">32</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#000">w</span> <span style="color:#000">:=</span> <span style="color:#a90d91">uint32</span>(<span style="color:#000">state</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">if</span> <span style="color:#000">v</span> <span style="color:#000">==</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#177500">// Counter is 0, no need to wait.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>   <span style="color:#a90d91">return</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#177500">// Increment waiters count.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  <span style="color:#a90d91">if</span> <span style="color:#000">atomic</span>.<span style="color:#000">CompareAndSwapUint64</span>(<span style="color:#000">statep</span>, <span style="color:#000">state</span>, <span style="color:#000">state</span><span style="color:#000">+</span><span style="color:#1c01ce">1</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#000">runtime_Semacquire</span>(<span style="color:#000">semap</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#a90d91">return</span>
</span></span><span style="display:flex;"><span> 	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="map-1">Map</h3>
<p>sync.Map 利用 atomic.Value 字段来实现只读部分并发，通过 dirty 字段实现加锁写部分并发，从而提高 Map 的并发性能。Map 的数据结构如下所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">type</span> <span style="color:#000">Map</span> <span style="color:#a90d91">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#000">mu</span> <span style="color:#000">sync</span>.<span style="color:#000">Mutex</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">read</span> <span style="color:#000">atomic</span>.<span style="color:#000">Value</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">dirty</span> <span style="color:#a90d91">map</span>[<span style="color:#a90d91">interface</span>{}]<span style="color:#000">*</span><span style="color:#000">entry</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">misses</span> <span style="color:#a90d91">int</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>read 字段主要用于读取，dirty 字段主要用于写入，从而减少读写的锁竞争。misses 字段会记录从 read 读取时没有命中的次数，当 missed 为命中次数等于 dirty 的长度时，会将 dirty 提升为 read。</p>
<p>Map 的 <strong>Load()</strong> 实现逻辑如下，</p>
<ul>
<li>首先获取 read 字段，从 read 中检索目标 key 是否存在，如果存在则直接返回。</li>
<li>当 key 不存在 read 中，且此时 amended 设置时，表明 dirty 中存在 read 中不存在的键值对。
<ul>
<li>首先对 read 进行<strong>二次检查</strong>，这是因为 missLocked 方法会将 dirty 提升为 read，如果上次加锁时进行了提升，那么这次加锁中的 read 字段就是最新的记录，不需要从 dirty 中检索。</li>
<li>反之，从 dirty 中检索键值对，并增加一次为命中纪录。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> (<span style="color:#000">m</span> <span style="color:#000">*</span><span style="color:#000">Map</span>) <span style="color:#000">loadReadOnly</span>() <span style="color:#000">readOnly</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">p</span> <span style="color:#000">:=</span> <span style="color:#000">m</span>.<span style="color:#000">read</span>.<span style="color:#000">Load</span>(); <span style="color:#000">p</span> <span style="color:#000">!=</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">return</span> <span style="color:#000">*</span><span style="color:#000">p</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">readOnly</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> (<span style="color:#000">m</span> <span style="color:#000">*</span><span style="color:#000">Map</span>) <span style="color:#000">Load</span>(<span style="color:#000">key</span> <span style="color:#000">any</span>) (<span style="color:#000">value</span> <span style="color:#000">any</span>, <span style="color:#000">ok</span> <span style="color:#a90d91">bool</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#000">read</span> <span style="color:#000">:=</span> <span style="color:#000">m</span>.<span style="color:#000">loadReadOnly</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#000">e</span>, <span style="color:#000">ok</span> <span style="color:#000">:=</span> <span style="color:#000">read</span>.<span style="color:#000">m</span>[<span style="color:#000">key</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> !<span style="color:#000">ok</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#000">read</span>.<span style="color:#000">amended</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">m</span>.<span style="color:#000">mu</span>.<span style="color:#000">Lock</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// Avoid reporting a spurious miss if m.dirty got promoted while we were
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#177500">// blocked on m.mu. (If further loads of the same key will not miss, it&#39;s
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#177500">// not worth copying the dirty map for this key.)
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#000">read</span> = <span style="color:#000">m</span>.<span style="color:#000">loadReadOnly</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#000">e</span>, <span style="color:#000">ok</span> = <span style="color:#000">read</span>.<span style="color:#000">m</span>[<span style="color:#000">key</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> !<span style="color:#000">ok</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#000">read</span>.<span style="color:#000">amended</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#000">e</span>, <span style="color:#000">ok</span> = <span style="color:#000">m</span>.<span style="color:#000">dirty</span>[<span style="color:#000">key</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#177500">// Regardless of whether the entry was present, record a miss: this key
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#177500">// will take the slow path until the dirty map is promoted to the read
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#177500">// map.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#000">m</span>.<span style="color:#000">missLocked</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#000">m</span>.<span style="color:#000">mu</span>.<span style="color:#000">Unlock</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> !<span style="color:#000">ok</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">return</span> <span style="color:#a90d91">nil</span>, <span style="color:#a90d91">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">e</span>.<span style="color:#000">load</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中 <strong>Store()</strong> 的实现逻辑如下，</p>
<ul>
<li>首先检索 read 中是否存在对应的 key，如果存在则通过 CAS 操作直接替换目标的值。</li>
<li>当 read 中不存在 key 时，通过加锁对 dirty 进行写，这里加锁用于避免并发中的写竞争。
<ul>
<li>第一个分支首先进行双重检查，与 Load( ) 中的逻辑相同，如果上一次锁竞争的胜者进行了 dirty 的提升，则本次加锁得到的 read 是更新过的，此时检查 read 即可获得键值对。其中第一个判断分支中的 e.unexpungeLocked( ) 标记表明 dirty 中不存在该键，需要在 dirty 中记录该键。</li>
<li>从 dirty 中检索 key 是否存在，如果存在简单的进行替换。</li>
<li>如果 dirty 中不存在，表明需要插入新的键，如果是第一次插入 dirty 此时先需要设置 read 为 amended，并为 dirty 分配空间。最后直接将键值对插入 dirty。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// Swap swaps the value for a key and returns the previous value if any.
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// The loaded result reports whether the key was present.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">m</span> <span style="color:#000">*</span><span style="color:#000">Map</span>) <span style="color:#000">Swap</span>(<span style="color:#000">key</span>, <span style="color:#000">value</span> <span style="color:#000">any</span>) (<span style="color:#000">previous</span> <span style="color:#000">any</span>, <span style="color:#000">loaded</span> <span style="color:#a90d91">bool</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#000">read</span> <span style="color:#000">:=</span> <span style="color:#000">m</span>.<span style="color:#000">loadReadOnly</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">e</span>, <span style="color:#000">ok</span> <span style="color:#000">:=</span> <span style="color:#000">read</span>.<span style="color:#000">m</span>[<span style="color:#000">key</span>]; <span style="color:#000">ok</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">v</span>, <span style="color:#000">ok</span> <span style="color:#000">:=</span> <span style="color:#000">e</span>.<span style="color:#000">trySwap</span>(<span style="color:#000">&amp;</span><span style="color:#000">value</span>); <span style="color:#000">ok</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a90d91">if</span> <span style="color:#000">v</span> <span style="color:#000">==</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a90d91">return</span> <span style="color:#a90d91">nil</span>, <span style="color:#a90d91">false</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a90d91">return</span> <span style="color:#000">*</span><span style="color:#000">v</span>, <span style="color:#a90d91">true</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">m</span>.<span style="color:#000">mu</span>.<span style="color:#000">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#000">read</span> = <span style="color:#000">m</span>.<span style="color:#000">loadReadOnly</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">e</span>, <span style="color:#000">ok</span> <span style="color:#000">:=</span> <span style="color:#000">read</span>.<span style="color:#000">m</span>[<span style="color:#000">key</span>]; <span style="color:#000">ok</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">e</span>.<span style="color:#000">unexpungeLocked</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#177500">// The entry was previously expunged, which implies that there is a
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#177500">// non-nil dirty map and this entry is not in it.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#000">m</span>.<span style="color:#000">dirty</span>[<span style="color:#000">key</span>] = <span style="color:#000">e</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">v</span> <span style="color:#000">:=</span> <span style="color:#000">e</span>.<span style="color:#000">swapLocked</span>(<span style="color:#000">&amp;</span><span style="color:#000">value</span>); <span style="color:#000">v</span> <span style="color:#000">!=</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#000">loaded</span> = <span style="color:#a90d91">true</span>
</span></span><span style="display:flex;"><span>			<span style="color:#000">previous</span> = <span style="color:#000">*</span><span style="color:#000">v</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#a90d91">else</span> <span style="color:#a90d91">if</span> <span style="color:#000">e</span>, <span style="color:#000">ok</span> <span style="color:#000">:=</span> <span style="color:#000">m</span>.<span style="color:#000">dirty</span>[<span style="color:#000">key</span>]; <span style="color:#000">ok</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">v</span> <span style="color:#000">:=</span> <span style="color:#000">e</span>.<span style="color:#000">swapLocked</span>(<span style="color:#000">&amp;</span><span style="color:#000">value</span>); <span style="color:#000">v</span> <span style="color:#000">!=</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#000">loaded</span> = <span style="color:#a90d91">true</span>
</span></span><span style="display:flex;"><span>			<span style="color:#000">previous</span> = <span style="color:#000">*</span><span style="color:#000">v</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#a90d91">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> !<span style="color:#000">read</span>.<span style="color:#000">amended</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#177500">// We&#39;re adding the first new key to the dirty map.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#177500">// Make sure it is allocated and mark the read-only map as incomplete.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#000">m</span>.<span style="color:#000">dirtyLocked</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#000">m</span>.<span style="color:#000">read</span>.<span style="color:#000">Store</span>(<span style="color:#000">&amp;</span><span style="color:#000">readOnly</span>{<span style="color:#000">m</span>: <span style="color:#000">read</span>.<span style="color:#000">m</span>, <span style="color:#000">amended</span>: <span style="color:#a90d91">true</span>})
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#000">m</span>.<span style="color:#000">dirty</span>[<span style="color:#000">key</span>] = <span style="color:#000">newEntry</span>(<span style="color:#000">value</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#000">m</span>.<span style="color:#000">mu</span>.<span style="color:#000">Unlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">previous</span>, <span style="color:#000">loaded</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>expunged 用于标识对应的 key 已经删除，由于在 read 中不能够并发的进行操作，因此通过 CAS 将 entry 中的 p 设置为 nil 来标识该键已经被删除，在 dirtyLocked( ) 方法中会检查 read 中的 entry 是否为 nil，如果为 nil 则标记为 expunged，不为 expunged 的键值对将复制到新的 dirty 中。而在 dirty 中，由于用 lock 加锁可以直接调用内置的 delete 关键字删除对应的键。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> (<span style="color:#000">m</span> <span style="color:#000">*</span><span style="color:#000">Map</span>) <span style="color:#000">dirtyLocked</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">m</span>.<span style="color:#000">dirty</span> <span style="color:#000">!=</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">read</span> <span style="color:#000">:=</span> <span style="color:#000">m</span>.<span style="color:#000">loadReadOnly</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#000">m</span>.<span style="color:#000">dirty</span> = <span style="color:#a90d91">make</span>(<span style="color:#a90d91">map</span>[<span style="color:#000">any</span>]<span style="color:#000">*</span><span style="color:#000">entry</span>, <span style="color:#a90d91">len</span>(<span style="color:#000">read</span>.<span style="color:#000">m</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">for</span> <span style="color:#000">k</span>, <span style="color:#000">e</span> <span style="color:#000">:=</span> <span style="color:#a90d91">range</span> <span style="color:#000">read</span>.<span style="color:#000">m</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> !<span style="color:#000">e</span>.<span style="color:#000">tryExpungeLocked</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#000">m</span>.<span style="color:#000">dirty</span>[<span style="color:#000">k</span>] = <span style="color:#000">e</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#177500">// LoadAndDelete deletes the value for a key, returning the previous value if any.
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// The loaded result reports whether the key was present.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">m</span> <span style="color:#000">*</span><span style="color:#000">Map</span>) <span style="color:#000">LoadAndDelete</span>(<span style="color:#000">key</span> <span style="color:#000">any</span>) (<span style="color:#000">value</span> <span style="color:#000">any</span>, <span style="color:#000">loaded</span> <span style="color:#a90d91">bool</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#000">read</span> <span style="color:#000">:=</span> <span style="color:#000">m</span>.<span style="color:#000">loadReadOnly</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#000">e</span>, <span style="color:#000">ok</span> <span style="color:#000">:=</span> <span style="color:#000">read</span>.<span style="color:#000">m</span>[<span style="color:#000">key</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> !<span style="color:#000">ok</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#000">read</span>.<span style="color:#000">amended</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">m</span>.<span style="color:#000">mu</span>.<span style="color:#000">Lock</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#000">read</span> = <span style="color:#000">m</span>.<span style="color:#000">loadReadOnly</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#000">e</span>, <span style="color:#000">ok</span> = <span style="color:#000">read</span>.<span style="color:#000">m</span>[<span style="color:#000">key</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> !<span style="color:#000">ok</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#000">read</span>.<span style="color:#000">amended</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#000">e</span>, <span style="color:#000">ok</span> = <span style="color:#000">m</span>.<span style="color:#000">dirty</span>[<span style="color:#000">key</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#a90d91">delete</span>(<span style="color:#000">m</span>.<span style="color:#000">dirty</span>, <span style="color:#000">key</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#177500">// Regardless of whether the entry was present, record a miss: this key
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#177500">// will take the slow path until the dirty map is promoted to the read
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#177500">// map.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#000">m</span>.<span style="color:#000">missLocked</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#000">m</span>.<span style="color:#000">mu</span>.<span style="color:#000">Unlock</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">ok</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">return</span> <span style="color:#000">e</span>.<span style="color:#a90d91">delete</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#a90d91">nil</span>, <span style="color:#a90d91">false</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> (<span style="color:#000">e</span> <span style="color:#000">*</span><span style="color:#000">entry</span>) <span style="color:#a90d91">delete</span>() (<span style="color:#000">value</span> <span style="color:#000">any</span>, <span style="color:#000">ok</span> <span style="color:#a90d91">bool</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">p</span> <span style="color:#000">:=</span> <span style="color:#000">e</span>.<span style="color:#000">p</span>.<span style="color:#000">Load</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">p</span> <span style="color:#000">==</span> <span style="color:#a90d91">nil</span> <span style="color:#000">||</span> <span style="color:#000">p</span> <span style="color:#000">==</span> <span style="color:#000">expunged</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a90d91">return</span> <span style="color:#a90d91">nil</span>, <span style="color:#a90d91">false</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">e</span>.<span style="color:#000">p</span>.<span style="color:#000">CompareAndSwap</span>(<span style="color:#000">p</span>, <span style="color:#a90d91">nil</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a90d91">return</span> <span style="color:#000">*</span><span style="color:#000">p</span>, <span style="color:#a90d91">true</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><input disabled="" type="checkbox"> Atomic 分析补充</li>
</ul>
<h3 id="context--定时器">Context &amp; 定时器</h3>
<h3 id="context">Context</h3>
<p>Context 接口如下，</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">type</span> <span style="color:#000">Context</span> <span style="color:#a90d91">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">Deadline</span>() (<span style="color:#000">deadline</span> <span style="color:#000">time</span>.<span style="color:#000">Time</span>, <span style="color:#000">ok</span> <span style="color:#a90d91">bool</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">Done</span>() <span style="color:#000">&lt;-</span><span style="color:#a90d91">chan</span> <span style="color:#a90d91">struct</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#000">Err</span>() <span style="color:#a90d91">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">Value</span>(<span style="color:#000">key</span> <span style="color:#000">any</span>) <span style="color:#000">any</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Context 实现 goroutine 之间的变量传递与信号共享，context.Background 与 context.Todo 都将返回内部结构体 emptyContext 变量，emptyContext 实现了 Context 接口的所有方法，但是所有方法都没有任何功能。background 作为所有 context 的上级，而 todo 作为不确定时的占位符。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">var</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#000">background</span> = <span style="color:#a90d91">new</span>(<span style="color:#000">emptyCtx</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">todo</span>       = <span style="color:#a90d91">new</span>(<span style="color:#000">emptyCtx</span>)
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">Background</span>() <span style="color:#000">Context</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">background</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">TODO</span>() <span style="color:#000">Context</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">todo</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>context.Cancel</strong> 提供一个 cancelFunc( ) 用于同步各 goroutine 的取消信号，结合 Done( ) 方法，各个 goroutine 通过监听 Done 返回的 channel，当发现 channel 关闭时，执行取消当前任务的命令实现各 goroutine 之间的停止动作的同步 。context.WithCancel( ) 将调用内部实现 withCancel，其代码如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">WithCancel</span>(<span style="color:#000">parent</span> <span style="color:#000">Context</span>) (<span style="color:#000">ctx</span> <span style="color:#000">Context</span>, <span style="color:#000">cancel</span> <span style="color:#000">CancelFunc</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#000">c</span> <span style="color:#000">:=</span> <span style="color:#000">withCancel</span>(<span style="color:#000">parent</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">c</span>, <span style="color:#a90d91">func</span>() { <span style="color:#000">c</span>.<span style="color:#000">cancel</span>(<span style="color:#a90d91">true</span>, <span style="color:#000">Canceled</span>, <span style="color:#a90d91">nil</span>) }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">withCancel</span>(<span style="color:#000">parent</span> <span style="color:#000">Context</span>) <span style="color:#000">*</span><span style="color:#000">cancelCtx</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">parent</span> <span style="color:#000">==</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">panic</span>(<span style="color:#c41a16">&#34;cannot create context from nil parent&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#000">c</span> <span style="color:#000">:=</span> <span style="color:#000">newCancelCtx</span>(<span style="color:#000">parent</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">propagateCancel</span>(<span style="color:#000">parent</span>, <span style="color:#000">c</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">c</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先在 newCancelCtx( ) 方法中创建新的 cancelCtx，其基本结构如下，</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">type</span> <span style="color:#000">cancelCtx</span> <span style="color:#a90d91">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">Context</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">mu</span>       <span style="color:#000">sync</span>.<span style="color:#000">Mutex</span>            <span style="color:#177500">// protects following fields
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">done</span>     <span style="color:#000">atomic</span>.<span style="color:#000">Value</span>          <span style="color:#177500">// of chan struct{}, created lazily, closed by first cancel call
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">children</span> <span style="color:#a90d91">map</span>[<span style="color:#000">canceler</span>]<span style="color:#a90d91">struct</span>{} <span style="color:#177500">// set to nil by the first cancel call
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">err</span>      <span style="color:#a90d91">error</span>                 <span style="color:#177500">// set to non-nil by the first cancel call
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">cause</span>    <span style="color:#a90d91">error</span>                 <span style="color:#177500">// set to non-nil by the first cancel call
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>}
</span></span></code></pre></div><p>在 propagateCancel( ) 方法中，如果 parent 是不可取消的 context，如 background，则直接返回，不需要构建 context 之间的取消关系。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000">done</span> <span style="color:#000">:=</span> <span style="color:#000">parent</span>.<span style="color:#000">Done</span>()
</span></span><span style="display:flex;"><span><span style="color:#a90d91">if</span> <span style="color:#000">done</span> <span style="color:#000">==</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">return</span> <span style="color:#177500">// parent is never canceled
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>}
</span></span></code></pre></div><p>如若 parent 是可取消的 context，接着会调用 Done( ) 方法判断上级 context 是否发送了取消同步信号，如果已经取消，则会调用 cancel 方法取消当前的 context</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">select</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">case</span> <span style="color:#000">&lt;-</span><span style="color:#000">done</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#177500">// parent is already canceled
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  <span style="color:#000">child</span>.<span style="color:#000">cancel</span>(<span style="color:#a90d91">false</span>, <span style="color:#000">parent</span>.<span style="color:#000">Err</span>(), <span style="color:#000">Cause</span>(<span style="color:#000">parent</span>))
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">return</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">default</span>:
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果取消信号未发送，则会检查 parent 是否是 cancelCtx 并转换为 $*cancelCtx$，首先进行双重检查，判断 p 是否已经取消（ err 不为空），如果已经取消则调用 child.cancel( ) 同步取消，否则将当前 cancelCtx 添加到 p 中的 children 中。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">if</span> <span style="color:#000">p</span>, <span style="color:#000">ok</span> <span style="color:#000">:=</span> <span style="color:#000">parentCancelCtx</span>(<span style="color:#000">parent</span>); <span style="color:#000">ok</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">p</span>.<span style="color:#000">mu</span>.<span style="color:#000">Lock</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">if</span> <span style="color:#000">p</span>.<span style="color:#000">err</span> <span style="color:#000">!=</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#177500">// parent has already been canceled
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>    <span style="color:#000">child</span>.<span style="color:#000">cancel</span>(<span style="color:#a90d91">false</span>, <span style="color:#000">p</span>.<span style="color:#000">err</span>, <span style="color:#000">p</span>.<span style="color:#000">cause</span>)
</span></span><span style="display:flex;"><span>  } <span style="color:#a90d91">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a90d91">if</span> <span style="color:#000">p</span>.<span style="color:#000">children</span> <span style="color:#000">==</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#000">p</span>.<span style="color:#000">children</span> = <span style="color:#a90d91">make</span>(<span style="color:#a90d91">map</span>[<span style="color:#000">canceler</span>]<span style="color:#a90d91">struct</span>{})
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#000">p</span>.<span style="color:#000">children</span>[<span style="color:#000">child</span>] = <span style="color:#a90d91">struct</span>{}{}
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000">p</span>.<span style="color:#000">mu</span>.<span style="color:#000">Unlock</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果 parent 不是 cancelCtx，则将创建一个新的 goroutine 并监听 parent 是否同步取消。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">go</span> <span style="color:#a90d91">func</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">select</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a90d91">case</span> <span style="color:#000">&lt;-</span><span style="color:#000">parent</span>.<span style="color:#000">Done</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#000">child</span>.<span style="color:#000">cancel</span>(<span style="color:#a90d91">false</span>, <span style="color:#000">parent</span>.<span style="color:#000">Err</span>(), <span style="color:#000">Cause</span>(<span style="color:#000">parent</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a90d91">case</span> <span style="color:#000">&lt;-</span><span style="color:#000">child</span>.<span style="color:#000">Done</span>():
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}()
</span></span></code></pre></div><p>通过 context.WithDeadline( )/WithTimeout( ) 可以获得<strong>定时取消的 cancelCtx( )</strong>， WithTimeout 是通过调用 withDeadline 方法实现的。而 withDeadline 实际上是借助 timer 和 cancelCtx 实现的。</p>
<p>首先 WithDeadline 会调用 Deadline( ) 方法判断 parent 是否的定时日期是否比当前设置的日期更早，如果更早则没必要设置更多的定时取消。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">if</span> <span style="color:#000">cur</span>, <span style="color:#000">ok</span> <span style="color:#000">:=</span> <span style="color:#000">parent</span>.<span style="color:#000">Deadline</span>(); <span style="color:#000">ok</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#000">cur</span>.<span style="color:#000">Before</span>(<span style="color:#000">d</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#177500">// The current deadline is already sooner than the new one.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  <span style="color:#a90d91">return</span> <span style="color:#000">WithCancel</span>(<span style="color:#000">parent</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>正常情况下，会创建一个 cancelCtx 同时调用 time.AfterFunc( ) 在定时器触发的时候同步取消信号。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#000">c</span> <span style="color:#000">:=</span> <span style="color:#000">&amp;</span><span style="color:#000">timerCtx</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#000">cancelCtx</span>: <span style="color:#000">newCancelCtx</span>(<span style="color:#000">parent</span>),
</span></span><span style="display:flex;"><span>  <span style="color:#000">deadline</span>:  <span style="color:#000">d</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#000">propagateCancel</span>(<span style="color:#000">parent</span>, <span style="color:#000">c</span>)
</span></span><span style="display:flex;"><span><span style="color:#000">dur</span> <span style="color:#000">:=</span> <span style="color:#000">time</span>.<span style="color:#000">Until</span>(<span style="color:#000">d</span>)
</span></span><span style="display:flex;"><span><span style="color:#a90d91">if</span> <span style="color:#000">dur</span> <span style="color:#000">&lt;=</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">c</span>.<span style="color:#000">cancel</span>(<span style="color:#a90d91">true</span>, <span style="color:#000">DeadlineExceeded</span>, <span style="color:#a90d91">nil</span>) <span style="color:#177500">// deadline has already passed
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  <span style="color:#a90d91">return</span> <span style="color:#000">c</span>, <span style="color:#a90d91">func</span>() { <span style="color:#000">c</span>.<span style="color:#000">cancel</span>(<span style="color:#a90d91">false</span>, <span style="color:#000">Canceled</span>, <span style="color:#a90d91">nil</span>) }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#000">c</span>.<span style="color:#000">mu</span>.<span style="color:#000">Lock</span>()
</span></span><span style="display:flex;"><span><span style="color:#a90d91">defer</span> <span style="color:#000">c</span>.<span style="color:#000">mu</span>.<span style="color:#000">Unlock</span>()
</span></span><span style="display:flex;"><span><span style="color:#a90d91">if</span> <span style="color:#000">c</span>.<span style="color:#000">err</span> <span style="color:#000">==</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">c</span>.<span style="color:#000">timer</span> = <span style="color:#000">time</span>.<span style="color:#000">AfterFunc</span>(<span style="color:#000">dur</span>, <span style="color:#a90d91">func</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#000">c</span>.<span style="color:#000">cancel</span>(<span style="color:#a90d91">true</span>, <span style="color:#000">DeadlineExceeded</span>, <span style="color:#a90d91">nil</span>)
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a90d91">return</span> <span style="color:#000">c</span>, <span style="color:#a90d91">func</span>() { <span style="color:#000">c</span>.<span style="color:#000">cancel</span>(<span style="color:#a90d91">true</span>, <span style="color:#000">Canceled</span>, <span style="color:#a90d91">nil</span>) }
</span></span></code></pre></div><h3 id="timer">Timer</h3>
<ul>
<li><input disabled="" type="checkbox"> Todo</li>
</ul>
<h2 id="go内部实现机制">Go内部实现机制</h2>
<h3 id="gmp-调度器">GMP 调度器</h3>
<ul>
<li>
<p>G 是指 Goroutine，M 是指线程，P 是指处理器。处理器连接一个线程和若干协程，负责协程的调度。通过调度器，使协程的调度发生在用户态，对比操作系统对线程的调度，降低了切换内核态和线程上下文的开销。</p>
<p><img src="golang.assets/2020-02-05-15808864354595-golang-scheduler-20240108121201784.png" alt="https://img.draveness.me/2020-02-05-15808864354595-golang-scheduler.png"></p>
</li>
</ul>
<p><strong>初始化</strong>，GMP 调度器会在程序启动时通过 <code>schedinit</code> 方法进行初始化，其中主要流程为确定最大处理器数量 procs，如果没有特殊指定环境变量，procs 默认为 CPU 核数量，即每个 CPU 绑定一个活跃线程，每个活跃线程绑定一个处理器。（注意，最大线程数并非最大处理数）</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#000">procs</span> <span style="color:#000">:=</span> <span style="color:#000">ncpu</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">n</span>, <span style="color:#000">ok</span> <span style="color:#000">:=</span> <span style="color:#000">atoi32</span>(<span style="color:#000">gogetenv</span>(<span style="color:#c41a16">&#34;GOMAXPROCS&#34;</span>)); <span style="color:#000">ok</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#000">n</span> &gt; <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">procs</span> = <span style="color:#000">n</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">procresize</span>(<span style="color:#000">procs</span>) <span style="color:#000">!=</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">throw</span>(<span style="color:#c41a16">&#34;unknown runnable goroutine during bootstrap&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p><code>procresize</code> 主要流程</p>
<ol>
<li>首先由第 22 行至 61 行代码初始化 P 处理器，使其数量达到 nprocs 指定的数量，</li>
<li>接下来第 88 行代码绑定一个处理器至线程，</li>
<li>第 119 行代码将其余处理器设置为 idle 状态。</li>
</ol>
<p>这样就完成了调度器的初始化，使处理器数量为 <code>procs</code>，并将其中一个活跃线程绑定一个处理器 <code>P</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">procresize</span>(<span style="color:#000">nprocs</span> <span style="color:#a90d91">int32</span>) <span style="color:#000">*</span><span style="color:#000">p</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">assertLockHeld</span>(<span style="color:#000">&amp;</span><span style="color:#000">sched</span>.<span style="color:#000">lock</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">assertWorldStopped</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">old</span> <span style="color:#000">:=</span> <span style="color:#000">gomaxprocs</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">old</span> &lt; <span style="color:#1c01ce">0</span> <span style="color:#000">||</span> <span style="color:#000">nprocs</span> <span style="color:#000">&lt;=</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">throw</span>(<span style="color:#c41a16">&#34;procresize: invalid arg&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">trace</span>.<span style="color:#000">enabled</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">traceGomaxprocs</span>(<span style="color:#000">nprocs</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// update statistics
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">now</span> <span style="color:#000">:=</span> <span style="color:#000">nanotime</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">sched</span>.<span style="color:#000">procresizetime</span> <span style="color:#000">!=</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">sched</span>.<span style="color:#000">totaltime</span> <span style="color:#000">+=</span> <span style="color:#a90d91">int64</span>(<span style="color:#000">old</span>) <span style="color:#000">*</span> (<span style="color:#000">now</span> <span style="color:#000">-</span> <span style="color:#000">sched</span>.<span style="color:#000">procresizetime</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#000">sched</span>.<span style="color:#000">procresizetime</span> = <span style="color:#000">now</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">maskWords</span> <span style="color:#000">:=</span> (<span style="color:#000">nprocs</span> <span style="color:#000">+</span> <span style="color:#1c01ce">31</span>) <span style="color:#000">/</span> <span style="color:#1c01ce">32</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// Grow allp if necessary.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">if</span> <span style="color:#000">nprocs</span> &gt; <span style="color:#a90d91">int32</span>(<span style="color:#a90d91">len</span>(<span style="color:#000">allp</span>)) {
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// Synchronize with retake, which could be running
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#177500">// concurrently since it doesn&#39;t run on a P.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#000">lock</span>(<span style="color:#000">&amp;</span><span style="color:#000">allpLock</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">nprocs</span> <span style="color:#000">&lt;=</span> <span style="color:#a90d91">int32</span>(<span style="color:#a90d91">cap</span>(<span style="color:#000">allp</span>)) {
</span></span><span style="display:flex;"><span>			<span style="color:#000">allp</span> = <span style="color:#000">allp</span>[:<span style="color:#000">nprocs</span>]
</span></span><span style="display:flex;"><span>		} <span style="color:#a90d91">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#000">nallp</span> <span style="color:#000">:=</span> <span style="color:#a90d91">make</span>([]<span style="color:#000">*</span><span style="color:#000">p</span>, <span style="color:#000">nprocs</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#177500">// Copy everything up to allp&#39;s cap so we
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#177500">// never lose old allocated Ps.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#a90d91">copy</span>(<span style="color:#000">nallp</span>, <span style="color:#000">allp</span>[:<span style="color:#a90d91">cap</span>(<span style="color:#000">allp</span>)])
</span></span><span style="display:flex;"><span>			<span style="color:#000">allp</span> = <span style="color:#000">nallp</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">maskWords</span> <span style="color:#000">&lt;=</span> <span style="color:#a90d91">int32</span>(<span style="color:#a90d91">cap</span>(<span style="color:#000">idlepMask</span>)) {
</span></span><span style="display:flex;"><span>			<span style="color:#000">idlepMask</span> = <span style="color:#000">idlepMask</span>[:<span style="color:#000">maskWords</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#000">timerpMask</span> = <span style="color:#000">timerpMask</span>[:<span style="color:#000">maskWords</span>]
</span></span><span style="display:flex;"><span>		} <span style="color:#a90d91">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#000">nidlepMask</span> <span style="color:#000">:=</span> <span style="color:#a90d91">make</span>([]<span style="color:#a90d91">uint32</span>, <span style="color:#000">maskWords</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#177500">// No need to copy beyond len, old Ps are irrelevant.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#a90d91">copy</span>(<span style="color:#000">nidlepMask</span>, <span style="color:#000">idlepMask</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#000">idlepMask</span> = <span style="color:#000">nidlepMask</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#000">ntimerpMask</span> <span style="color:#000">:=</span> <span style="color:#a90d91">make</span>([]<span style="color:#a90d91">uint32</span>, <span style="color:#000">maskWords</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a90d91">copy</span>(<span style="color:#000">ntimerpMask</span>, <span style="color:#000">timerpMask</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#000">timerpMask</span> = <span style="color:#000">ntimerpMask</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#000">unlock</span>(<span style="color:#000">&amp;</span><span style="color:#000">allpLock</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// initialize new P&#39;s
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">for</span> <span style="color:#000">i</span> <span style="color:#000">:=</span> <span style="color:#000">old</span>; <span style="color:#000">i</span> &lt; <span style="color:#000">nprocs</span>; <span style="color:#000">i</span><span style="color:#000">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">pp</span> <span style="color:#000">:=</span> <span style="color:#000">allp</span>[<span style="color:#000">i</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">pp</span> <span style="color:#000">==</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#000">pp</span> = <span style="color:#a90d91">new</span>(<span style="color:#000">p</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#000">pp</span>.<span style="color:#000">init</span>(<span style="color:#000">i</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#000">atomicstorep</span>(<span style="color:#000">unsafe</span>.<span style="color:#000">Pointer</span>(<span style="color:#000">&amp;</span><span style="color:#000">allp</span>[<span style="color:#000">i</span>]), <span style="color:#000">unsafe</span>.<span style="color:#000">Pointer</span>(<span style="color:#000">pp</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">gp</span> <span style="color:#000">:=</span> <span style="color:#000">getg</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">gp</span>.<span style="color:#000">m</span>.<span style="color:#000">p</span> <span style="color:#000">!=</span> <span style="color:#1c01ce">0</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#000">gp</span>.<span style="color:#000">m</span>.<span style="color:#000">p</span>.<span style="color:#000">ptr</span>().<span style="color:#000">id</span> &lt; <span style="color:#000">nprocs</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// continue to use the current P
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#000">gp</span>.<span style="color:#000">m</span>.<span style="color:#000">p</span>.<span style="color:#000">ptr</span>().<span style="color:#000">status</span> = <span style="color:#000">_Prunning</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">gp</span>.<span style="color:#000">m</span>.<span style="color:#000">p</span>.<span style="color:#000">ptr</span>().<span style="color:#000">mcache</span>.<span style="color:#000">prepareForSweep</span>()
</span></span><span style="display:flex;"><span>	} <span style="color:#a90d91">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// release the current P and acquire allp[0].
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#177500">//
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#177500">// We must do this before destroying our current P
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#177500">// because p.destroy itself has write barriers, so we
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#177500">// need to do that from a valid P.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#a90d91">if</span> <span style="color:#000">gp</span>.<span style="color:#000">m</span>.<span style="color:#000">p</span> <span style="color:#000">!=</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a90d91">if</span> <span style="color:#000">trace</span>.<span style="color:#000">enabled</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#177500">// Pretend that we were descheduled
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>				<span style="color:#177500">// and then scheduled again to keep
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>				<span style="color:#177500">// the trace sane.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>				<span style="color:#000">traceGoSched</span>()
</span></span><span style="display:flex;"><span>				<span style="color:#000">traceProcStop</span>(<span style="color:#000">gp</span>.<span style="color:#000">m</span>.<span style="color:#000">p</span>.<span style="color:#000">ptr</span>())
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#000">gp</span>.<span style="color:#000">m</span>.<span style="color:#000">p</span>.<span style="color:#000">ptr</span>().<span style="color:#000">m</span> = <span style="color:#1c01ce">0</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#000">gp</span>.<span style="color:#000">m</span>.<span style="color:#000">p</span> = <span style="color:#1c01ce">0</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">pp</span> <span style="color:#000">:=</span> <span style="color:#000">allp</span>[<span style="color:#1c01ce">0</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#000">pp</span>.<span style="color:#000">m</span> = <span style="color:#1c01ce">0</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">pp</span>.<span style="color:#000">status</span> = <span style="color:#000">_Pidle</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">acquirep</span>(<span style="color:#000">pp</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">trace</span>.<span style="color:#000">enabled</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#000">traceGoStart</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// g.m.p is now set, so we no longer need mcache0 for bootstrapping.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">mcache0</span> = <span style="color:#a90d91">nil</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// release resources from unused P&#39;s
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">for</span> <span style="color:#000">i</span> <span style="color:#000">:=</span> <span style="color:#000">nprocs</span>; <span style="color:#000">i</span> &lt; <span style="color:#000">old</span>; <span style="color:#000">i</span><span style="color:#000">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">pp</span> <span style="color:#000">:=</span> <span style="color:#000">allp</span>[<span style="color:#000">i</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#000">pp</span>.<span style="color:#000">destroy</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// can&#39;t free P itself because it can be referenced by an M in syscall
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// Trim allp.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">if</span> <span style="color:#a90d91">int32</span>(<span style="color:#a90d91">len</span>(<span style="color:#000">allp</span>)) <span style="color:#000">!=</span> <span style="color:#000">nprocs</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">lock</span>(<span style="color:#000">&amp;</span><span style="color:#000">allpLock</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#000">allp</span> = <span style="color:#000">allp</span>[:<span style="color:#000">nprocs</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#000">idlepMask</span> = <span style="color:#000">idlepMask</span>[:<span style="color:#000">maskWords</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#000">timerpMask</span> = <span style="color:#000">timerpMask</span>[:<span style="color:#000">maskWords</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#000">unlock</span>(<span style="color:#000">&amp;</span><span style="color:#000">allpLock</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">var</span> <span style="color:#000">runnablePs</span> <span style="color:#000">*</span><span style="color:#000">p</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">for</span> <span style="color:#000">i</span> <span style="color:#000">:=</span> <span style="color:#000">nprocs</span> <span style="color:#000">-</span> <span style="color:#1c01ce">1</span>; <span style="color:#000">i</span> <span style="color:#000">&gt;=</span> <span style="color:#1c01ce">0</span>; <span style="color:#000">i</span><span style="color:#000">--</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">pp</span> <span style="color:#000">:=</span> <span style="color:#000">allp</span>[<span style="color:#000">i</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">gp</span>.<span style="color:#000">m</span>.<span style="color:#000">p</span>.<span style="color:#000">ptr</span>() <span style="color:#000">==</span> <span style="color:#000">pp</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a90d91">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#000">pp</span>.<span style="color:#000">status</span> = <span style="color:#000">_Pidle</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">runqempty</span>(<span style="color:#000">pp</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#000">pidleput</span>(<span style="color:#000">pp</span>, <span style="color:#000">now</span>)
</span></span><span style="display:flex;"><span>		} <span style="color:#a90d91">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#000">pp</span>.<span style="color:#000">m</span>.<span style="color:#000">set</span>(<span style="color:#000">mget</span>())
</span></span><span style="display:flex;"><span>			<span style="color:#000">pp</span>.<span style="color:#000">link</span>.<span style="color:#000">set</span>(<span style="color:#000">runnablePs</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#000">runnablePs</span> = <span style="color:#000">pp</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#000">stealOrder</span>.<span style="color:#000">reset</span>(<span style="color:#a90d91">uint32</span>(<span style="color:#000">nprocs</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">var</span> <span style="color:#000">int32p</span> <span style="color:#000">*</span><span style="color:#a90d91">int32</span> = <span style="color:#000">&amp;</span><span style="color:#000">gomaxprocs</span> <span style="color:#177500">// make compiler check that gomaxprocs is an int32
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#000">atomic</span>.<span style="color:#000">Store</span>((<span style="color:#000">*</span><span style="color:#a90d91">uint32</span>)(<span style="color:#000">unsafe</span>.<span style="color:#000">Pointer</span>(<span style="color:#000">int32p</span>)), <span style="color:#a90d91">uint32</span>(<span style="color:#000">nprocs</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">old</span> <span style="color:#000">!=</span> <span style="color:#000">nprocs</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// Notify the limiter that the amount of procs has changed.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#000">gcCPULimiter</span>.<span style="color:#000">resetCapacity</span>(<span style="color:#000">now</span>, <span style="color:#000">nprocs</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">runnablePs</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>调度循环</strong>，完成调度器的初始化后，后续对 goroutine 的调度都将借助 <code>schedule</code> 函数进行调度。调度循环基本流程如下图所示，首先进入 <code>schedule</code> 函数，该方法将找到一个合适的 goroutine，接着通过 <code>execute</code> 函数调用 <code>gogo</code> 汇编代码去执行对应的 goroutine，当 goroutine 退出时，将调用 <code>schedule</code> 进入下一轮循环。</p>
<p>简单的调度循环流程如上所述，但是在<em>系统调用、协作式抢占调度</em>等场景下，也会出发 <code>schedule</code> 函数进行调度。因此 Go 语言中的调度器触发是非常复杂的一个过程。</p>
<p><img src="golang.assets/2020-02-05-15808864354669-golang-scheduler-loop-20240108121201418.png" alt="https://img.draveness.me/2020-02-05-15808864354669-golang-scheduler-loop.png"></p>
<p><code>schedule</code> 函数的基本流程是：</p>
<ol>
<li>第 10 行代码判断当前的线程 m 是否有锁定的协程 g，如果有则会将当前线程 m 的处理器 p 解绑，并将当前线程 m 阻塞，直到另一个线程的重新调度当前锁定的协程 g 为止。</li>
<li>第 32 行代码通过 <code>findRunnable</code> 函数获取一个可以执行的协程 g</li>
<li>第 41-56 行代码判断当前协程是否允许调度，如果不允许调度则放回 <code>disable.runnable</code> 队列，直至允许调度。</li>
<li>第 60 行代码判断 <code>findRunnable</code> 返回的协程 g 是否为系统协程（如 GC），如果是系统协程，则需要尝试唤醒另一个处理器 P 执行协程 g 。</li>
<li>第 63 行代码判断对应的协程 g 是否已经有锁定的线程 m，如果有，则需要唤醒原对应的线程，并使当前调度线程进入阻塞，该阻塞的线程等待唤醒后重新绑定处理器 P 并重新进入调度。</li>
<li>如果上述 3、4、5 均不满足，说明该协程是普通的协程，调用 <code>execute</code> 函数执行对应的协程。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// One round of scheduler: find a runnable goroutine and execute it.
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// Never returns.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> <span style="color:#000">schedule</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#000">mp</span> <span style="color:#000">:=</span> <span style="color:#000">getg</span>().<span style="color:#000">m</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">mp</span>.<span style="color:#000">locks</span> <span style="color:#000">!=</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">throw</span>(<span style="color:#c41a16">&#34;schedule: holding locks&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">mp</span>.<span style="color:#000">lockedg</span> <span style="color:#000">!=</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">stoplockedm</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#000">execute</span>(<span style="color:#000">mp</span>.<span style="color:#000">lockedg</span>.<span style="color:#000">ptr</span>(), <span style="color:#a90d91">false</span>) <span style="color:#177500">// Never returns.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// We should not schedule away from a g that is executing a cgo call,
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// since the cgo call is using the m&#39;s g0 stack.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">if</span> <span style="color:#000">mp</span>.<span style="color:#000">incgo</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">throw</span>(<span style="color:#c41a16">&#34;schedule: in cgo&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000">top</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#000">pp</span> <span style="color:#000">:=</span> <span style="color:#000">mp</span>.<span style="color:#000">p</span>.<span style="color:#000">ptr</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#000">pp</span>.<span style="color:#000">preempt</span> = <span style="color:#a90d91">false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// Safety check: if we are spinning, the run queue should be empty.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// Check this before calling checkTimers, as that might call
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// goready to put a ready goroutine on the local run queue.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">if</span> <span style="color:#000">mp</span>.<span style="color:#000">spinning</span> <span style="color:#000">&amp;&amp;</span> (<span style="color:#000">pp</span>.<span style="color:#000">runnext</span> <span style="color:#000">!=</span> <span style="color:#1c01ce">0</span> <span style="color:#000">||</span> <span style="color:#000">pp</span>.<span style="color:#000">runqhead</span> <span style="color:#000">!=</span> <span style="color:#000">pp</span>.<span style="color:#000">runqtail</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#000">throw</span>(<span style="color:#c41a16">&#34;schedule: spinning with local work&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">gp</span>, <span style="color:#000">inheritTime</span>, <span style="color:#000">tryWakeP</span> <span style="color:#000">:=</span> <span style="color:#000">findRunnable</span>() <span style="color:#177500">// blocks until work is available
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// This thread is going to run a goroutine and is not spinning anymore,
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// so if it was marked as spinning we need to reset it now and potentially
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// start a new spinning M.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">if</span> <span style="color:#000">mp</span>.<span style="color:#000">spinning</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">resetspinning</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">sched</span>.<span style="color:#000">disable</span>.<span style="color:#000">user</span> <span style="color:#000">&amp;&amp;</span> !<span style="color:#000">schedEnabled</span>(<span style="color:#000">gp</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// Scheduling of this goroutine is disabled. Put it on
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#177500">// the list of pending runnable goroutines for when we
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#177500">// re-enable user scheduling and look again.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#000">lock</span>(<span style="color:#000">&amp;</span><span style="color:#000">sched</span>.<span style="color:#000">lock</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> <span style="color:#000">schedEnabled</span>(<span style="color:#000">gp</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#177500">// Something re-enabled scheduling while we
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#177500">// were acquiring the lock.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>			<span style="color:#000">unlock</span>(<span style="color:#000">&amp;</span><span style="color:#000">sched</span>.<span style="color:#000">lock</span>)
</span></span><span style="display:flex;"><span>		} <span style="color:#a90d91">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#000">sched</span>.<span style="color:#000">disable</span>.<span style="color:#000">runnable</span>.<span style="color:#000">pushBack</span>(<span style="color:#000">gp</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#000">sched</span>.<span style="color:#000">disable</span>.<span style="color:#000">n</span><span style="color:#000">++</span>
</span></span><span style="display:flex;"><span>			<span style="color:#000">unlock</span>(<span style="color:#000">&amp;</span><span style="color:#000">sched</span>.<span style="color:#000">lock</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a90d91">goto</span> <span style="color:#000">top</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#177500">// If about to schedule a not-normal goroutine (a GCworker or tracereader),
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#177500">// wake a P if there is one.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>	<span style="color:#a90d91">if</span> <span style="color:#000">tryWakeP</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">wakep</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">gp</span>.<span style="color:#000">lockedm</span> <span style="color:#000">!=</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#177500">// Hands off own p to the locked m,
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#177500">// then blocks waiting for a new p.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>		<span style="color:#000">startlockedm</span>(<span style="color:#000">gp</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">goto</span> <span style="color:#000">top</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">execute</span>(<span style="color:#000">gp</span>, <span style="color:#000">inheritTime</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>调度触发</strong>，除线程启动的入口 <code>mstart</code> 函数后调度循环中的 <code>goexit</code> 函数会调用 <code>schedule</code> 外，系统调用、主动挂起协程、协作式抢占调度及系统监控等场景都会触发调度。</p>
<ul>
<li><strong>系统调用</strong></li>
<li><input disabled="" type="checkbox"> 补充完善调用触发的分析</li>
</ul>
<h3 id="网络轮询器">网络轮询器</h3>
<ul>
<li>Go 语言中的网络轮询器利用了操作系统的 IO 多路复用，为网络 IO、文件 IO、定时器等提供 IO 多路复用的能力。</li>
<li>IO 多路复用包括 select/poll/epoll 等，其中 epoll 为 linux 系统专用 IO 多路复用，其性能相比 select/poll 有显著的提升。因为内核保存了 epoll 的文件描述符，不需要在每次调用时，将文件描述符复制到内核空间。</li>
<li>由于网络轮询器的存在，协程中存在 IO 阻塞时，协程将进入阻塞状态，但是此时处理器 P 将绑定新的协程，使得处理器 P 对应的线程不至阻塞，当网络轮询器发现对应的 IO 事件就绪时，将原阻塞协程加入运行队列中，使得原协程在未来某一时刻恢复运行状态。因此在 Go 语言中，不需要显式实现 IO 多路复用功能。</li>
</ul>
<h3 id="系统监控">系统监控</h3>
<h3 id="内存分配器">内存分配器</h3>
<h3 id="垃圾收集器">垃圾收集器</h3>
<h3 id="gc-算法">GC 算法</h3>
<p>GC(Garbage Collection) 算法用于回收内存中没用引用可以到达的垃圾对象。</p>
<h3 id="栈内存管理">栈内存管理</h3>
<h2 id="标准库">标准库</h2>
<h3 id="go-container">Go container</h3>
<h3 id="list-1">List</h3>
<p>是一个双向链表。使用 List 结构体存储头节点和链表长度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// List represents a doubly linked list.
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// The zero value for List is an empty list ready to use.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">type</span> <span style="color:#000">List</span> <span style="color:#a90d91">struct</span> {
</span></span><span style="display:flex;"><span> <span style="color:#000">root</span> <span style="color:#000">Element</span> <span style="color:#177500">// sentinel list element, only &amp;root, root.prev, and root.next are used
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">len</span>  <span style="color:#a90d91">int</span>     <span style="color:#177500">// current list length excluding (this) sentinel element
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>}
</span></span></code></pre></div><p>节点为 Element 元素。包括前后指针，和指向所属的 list 的指针，使用 any 存储任意值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// Element is an element of a linked list.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">type</span> <span style="color:#000">Element</span> <span style="color:#a90d91">struct</span> {
</span></span><span style="display:flex;"><span> <span style="color:#177500">// Next and previous pointers in the doubly-linked list of elements.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// To simplify the implementation, internally a list l is implemented
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// as a ring, such that &amp;l.root is both the next element of the last
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// list element (l.Back()) and the previous element of the first list
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#177500">// element (l.Front()).
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">next</span>, <span style="color:#000">prev</span> <span style="color:#000">*</span><span style="color:#000">Element</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#177500">// The list to which this element belongs.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">list</span> <span style="color:#000">*</span><span style="color:#000">List</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#177500">// The value stored with this element.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">Value</span> <span style="color:#000">any</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>内部实现 insert() / remove() / move() 等基本 API 操作，衍生出暴露的诸如 InsertBefore() 等 API。</p>
<p><strong>insert()</strong> 实现如下，首先确定插入节点 e 的前后指针，接着更新 e 的前后节点的 next 和 prev 指针。此外赋值所属 list 指针和增加 list 表示长度。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// insert inserts e after at, increments l.len, and returns e.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">l</span> <span style="color:#000">*</span><span style="color:#000">List</span>) <span style="color:#000">insert</span>(<span style="color:#000">e</span>, <span style="color:#000">at</span> <span style="color:#000">*</span><span style="color:#000">Element</span>) <span style="color:#000">*</span><span style="color:#000">Element</span> {
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">prev</span> = <span style="color:#000">at</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">next</span> = <span style="color:#000">at</span>.<span style="color:#000">next</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">prev</span>.<span style="color:#000">next</span> = <span style="color:#000">e</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">next</span>.<span style="color:#000">prev</span> = <span style="color:#000">e</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">list</span> = <span style="color:#000">l</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">l</span>.<span style="color:#000">len</span><span style="color:#000">++</span>
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">return</span> <span style="color:#000">e</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>remove()</strong> 实现如下，更新前后节点的 next 和 prev 指针，然后释放当前节点的引用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// remove removes e from its list, decrements l.len
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">l</span> <span style="color:#000">*</span><span style="color:#000">List</span>) <span style="color:#000">remove</span>(<span style="color:#000">e</span> <span style="color:#000">*</span><span style="color:#000">Element</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">prev</span>.<span style="color:#000">next</span> = <span style="color:#000">e</span>.<span style="color:#000">next</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">next</span>.<span style="color:#000">prev</span> = <span style="color:#000">e</span>.<span style="color:#000">prev</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">next</span> = <span style="color:#a90d91">nil</span> <span style="color:#177500">// avoid memory leaks
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">e</span>.<span style="color:#000">prev</span> = <span style="color:#a90d91">nil</span> <span style="color:#177500">// avoid memory leaks
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">e</span>.<span style="color:#000">list</span> = <span style="color:#a90d91">nil</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">l</span>.<span style="color:#000">len</span><span style="color:#000">--</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>move()</strong> 的实现如下，首先判断是否需要移动，接着更新当前节点的前后节点指针，进行删除，最后更新插入位置的指针和插入位置前后节点的指针。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// move moves e to next to at.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">l</span> <span style="color:#000">*</span><span style="color:#000">List</span>) <span style="color:#000">move</span>(<span style="color:#000">e</span>, <span style="color:#000">at</span> <span style="color:#000">*</span><span style="color:#000">Element</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">e</span> <span style="color:#000">==</span> <span style="color:#000">at</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">return</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">prev</span>.<span style="color:#000">next</span> = <span style="color:#000">e</span>.<span style="color:#000">next</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">next</span>.<span style="color:#000">prev</span> = <span style="color:#000">e</span>.<span style="color:#000">prev</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">prev</span> = <span style="color:#000">at</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">next</span> = <span style="color:#000">at</span>.<span style="color:#000">next</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">prev</span>.<span style="color:#000">next</span> = <span style="color:#000">e</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">e</span>.<span style="color:#000">next</span>.<span style="color:#000">prev</span> = <span style="color:#000">e</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="ring-1">Ring</h3>
<p>是一个环形链表。环中的每一个元素由 Ring 构成。Ring 的组成如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// A Ring is an element of a circular list, or ring.
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// Rings do not have a beginning or end; a pointer to any ring element
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// serves as reference to the entire ring. Empty rings are represented
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// as nil Ring pointers. The zero value for a Ring is a one-element
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// ring with a nil Value.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">type</span> <span style="color:#000">Ring</span> <span style="color:#a90d91">struct</span> {
</span></span><span style="display:flex;"><span> <span style="color:#000">next</span>, <span style="color:#000">prev</span> <span style="color:#000">*</span><span style="color:#000">Ring</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">Value</span>      <span style="color:#000">any</span> <span style="color:#177500">// for use by client; untouched by this library
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>}
</span></span></code></pre></div><p>Ring 主要包括三类操作，1)、New() / Link() / Unlink() 等初始化及链接和断开环的操作。2)、Next() / Prev() / Move() 等移动节点的操作。3)、Do() 遍历环中节点的操作。</p>
<p><strong>New()</strong> 用来初始化环，New() 主要逻辑如下，首先判断长度是否大于零，然后初始化一个 Ring 指针，然后根据长度增加节点，最后链接头尾节点。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// New creates a ring of n elements.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> <span style="color:#000">New</span>(<span style="color:#000">n</span> <span style="color:#a90d91">int</span>) <span style="color:#000">*</span><span style="color:#000">Ring</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">n</span> <span style="color:#000">&lt;=</span> <span style="color:#1c01ce">0</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">return</span> <span style="color:#a90d91">nil</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#000">r</span> <span style="color:#000">:=</span> <span style="color:#a90d91">new</span>(<span style="color:#000">Ring</span>)
</span></span><span style="display:flex;"><span> <span style="color:#000">p</span> <span style="color:#000">:=</span> <span style="color:#000">r</span>
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">for</span> <span style="color:#000">i</span> <span style="color:#000">:=</span> <span style="color:#1c01ce">1</span>; <span style="color:#000">i</span> &lt; <span style="color:#000">n</span>; <span style="color:#000">i</span><span style="color:#000">++</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">p</span>.<span style="color:#000">next</span> = <span style="color:#000">&amp;</span><span style="color:#000">Ring</span>{<span style="color:#000">prev</span>: <span style="color:#000">p</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#000">p</span> = <span style="color:#000">p</span>.<span style="color:#000">next</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#000">p</span>.<span style="color:#000">next</span> = <span style="color:#000">r</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">r</span>.<span style="color:#000">prev</span> = <span style="color:#000">p</span>
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">return</span> <span style="color:#000">r</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Link()</strong> 用于链接两个环，Link() 的实现如下，源码中强调了不能使用多重赋值，是因为多重赋值是不能保证赋值顺序的，而这里我们需要强调赋值的顺序。</p>
<p>首先获取当前节点 r 的下一个节点及目标节点 s 的最后一个节点，在节点 s 的头部进行链接，即 r.next = s 和 s.prev = r，接着在节点 s 的尾部进行链接，即 p.next() = n 和 n.prev = p。</p>
<p>如果 r 和 s 是同一个环中的节点，那么 r 和 s 中间的节点将会移除，r 和 s 链接在一起，剩下的部分链接在一起。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> (<span style="color:#000">r</span> <span style="color:#000">*</span><span style="color:#000">Ring</span>) <span style="color:#000">Link</span>(<span style="color:#000">s</span> <span style="color:#000">*</span><span style="color:#000">Ring</span>) <span style="color:#000">*</span><span style="color:#000">Ring</span> {
</span></span><span style="display:flex;"><span> <span style="color:#000">n</span> <span style="color:#000">:=</span> <span style="color:#000">r</span>.<span style="color:#000">Next</span>()
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">s</span> <span style="color:#000">!=</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">p</span> <span style="color:#000">:=</span> <span style="color:#000">s</span>.<span style="color:#000">Prev</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#177500">// Note: Cannot use multiple assignment because
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  <span style="color:#177500">// evaluation order of LHS is not specified.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  <span style="color:#000">r</span>.<span style="color:#000">next</span> = <span style="color:#000">s</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000">s</span>.<span style="color:#000">prev</span> = <span style="color:#000">r</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000">n</span>.<span style="color:#000">prev</span> = <span style="color:#000">p</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000">p</span>.<span style="color:#000">next</span> = <span style="color:#000">n</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">return</span> <span style="color:#000">n</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Next() / Move() / Prev()</strong> 逻辑相近，其实现如下。</p>
<p><em>其中 if r.next == nil 的判断可能是用户自己初始化的 Ring 结构体没有成环的检查 🤔️。</em></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// Next returns the next ring element. r must not be empty.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">r</span> <span style="color:#000">*</span><span style="color:#000">Ring</span>) <span style="color:#000">Next</span>() <span style="color:#000">*</span><span style="color:#000">Ring</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">r</span>.<span style="color:#000">next</span> <span style="color:#000">==</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">return</span> <span style="color:#000">r</span>.<span style="color:#000">init</span>()
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">return</span> <span style="color:#000">r</span>.<span style="color:#000">next</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#177500">// Prev returns the previous ring element. r must not be empty.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">r</span> <span style="color:#000">*</span><span style="color:#000">Ring</span>) <span style="color:#000">Prev</span>() <span style="color:#000">*</span><span style="color:#000">Ring</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">r</span>.<span style="color:#000">next</span> <span style="color:#000">==</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">return</span> <span style="color:#000">r</span>.<span style="color:#000">init</span>()
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">return</span> <span style="color:#000">r</span>.<span style="color:#000">prev</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#177500">// Move moves n % r.Len() elements backward (n &lt; 0) or forward (n &gt;= 0)
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// in the ring and returns that ring element. r must not be empty.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">r</span> <span style="color:#000">*</span><span style="color:#000">Ring</span>) <span style="color:#000">Move</span>(<span style="color:#000">n</span> <span style="color:#a90d91">int</span>) <span style="color:#000">*</span><span style="color:#000">Ring</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">r</span>.<span style="color:#000">next</span> <span style="color:#000">==</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">return</span> <span style="color:#000">r</span>.<span style="color:#000">init</span>()
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">switch</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">case</span> <span style="color:#000">n</span> &lt; <span style="color:#1c01ce">0</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">for</span> ; <span style="color:#000">n</span> &lt; <span style="color:#1c01ce">0</span>; <span style="color:#000">n</span><span style="color:#000">++</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#000">r</span> = <span style="color:#000">r</span>.<span style="color:#000">prev</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">case</span> <span style="color:#000">n</span> &gt; <span style="color:#1c01ce">0</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">for</span> ; <span style="color:#000">n</span> &gt; <span style="color:#1c01ce">0</span>; <span style="color:#000">n</span><span style="color:#000">--</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#000">r</span> = <span style="color:#000">r</span>.<span style="color:#000">next</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">return</span> <span style="color:#000">r</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Do()</strong> 函数逻辑即遍历环，并对每个节点应用 f()。<em>这种设计模式有一定的局限，如果 Do 能够传入可变参数列表，并将可变参数列表传入 f 中，这样可以将外部变量代入处理函数 f 中，这样在某些统计函数时带来便利性，如 Do(f(len), len) 这种模式。</em></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#177500">// Do calls function f on each element of the ring, in forward order.
</span></span></span><span style="display:flex;"><span><span style="color:#177500">// The behavior of Do is undefined if f changes *r.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span><span style="color:#a90d91">func</span> (<span style="color:#000">r</span> <span style="color:#000">*</span><span style="color:#000">Ring</span>) <span style="color:#000">Do</span>(<span style="color:#000">f</span> <span style="color:#a90d91">func</span>(<span style="color:#000">any</span>)) {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">if</span> <span style="color:#000">r</span> <span style="color:#000">!=</span> <span style="color:#a90d91">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">f</span>(<span style="color:#000">r</span>.<span style="color:#000">Value</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">for</span> <span style="color:#000">p</span> <span style="color:#000">:=</span> <span style="color:#000">r</span>.<span style="color:#000">Next</span>(); <span style="color:#000">p</span> <span style="color:#000">!=</span> <span style="color:#000">r</span>; <span style="color:#000">p</span> = <span style="color:#000">p</span>.<span style="color:#000">next</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#000">f</span>(<span style="color:#000">p</span>.<span style="color:#000">Value</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>相比于 List 的双向链表，Ring 是有限制的双向链表，Ring 有以下特点。</p>
<ol>
<li>无法在 O(1) 时间复杂度内确定环的长度。</li>
<li>不能直接调用 Insert、Remove 等传统链表操作。</li>
</ol>
<h3 id="heap-1">Heap</h3>
<blockquote>
<p>container/heap</p>
</blockquote>
<p>实现了堆的数据结构，这里采用 interface 的模式描述堆的特性，并不直接实现堆的容器。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">type</span> <span style="color:#000">Interface</span> <span style="color:#a90d91">interface</span> {
</span></span><span style="display:flex;"><span> <span style="color:#000">sort</span>.<span style="color:#000">Interface</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">Push</span>(<span style="color:#000">x</span> <span style="color:#000">any</span>) <span style="color:#177500">// add x as element Len()
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">Pop</span>() <span style="color:#000">any</span>   <span style="color:#177500">// remove and return element Len() - 1.
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">type</span> <span style="color:#000">Interface</span> <span style="color:#a90d91">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">Len</span>() <span style="color:#a90d91">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">Less</span>(<span style="color:#000">i</span>, <span style="color:#000">j</span> <span style="color:#a90d91">int</span>) <span style="color:#a90d91">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">Swap</span>(<span style="color:#000">i</span>, <span style="color:#000">j</span> <span style="color:#a90d91">int</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Heap 的核心方法为 up() / down()，在《算法》一书中为 swim() / sink()，意为上浮和下沉。</p>
<p><strong>up()</strong> 的实现如下，首先 i := (j - 1) / 2 找到对应节点的父节点，<em>这里是从 0 开始计算节点</em>，接着判断节点是否为堆顶，判断是否需要进行交换，不满足条件退出循环，否则，交换父节点于子节点，并对父节点迭代操作。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">up</span>(<span style="color:#000">h</span> <span style="color:#000">Interface</span>, <span style="color:#000">j</span> <span style="color:#a90d91">int</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">for</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">i</span> <span style="color:#000">:=</span> (<span style="color:#000">j</span> <span style="color:#000">-</span> <span style="color:#1c01ce">1</span>) <span style="color:#000">/</span> <span style="color:#1c01ce">2</span> <span style="color:#177500">// parent
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  <span style="color:#a90d91">if</span> <span style="color:#000">i</span> <span style="color:#000">==</span> <span style="color:#000">j</span> <span style="color:#000">||</span> !<span style="color:#000">h</span>.<span style="color:#000">Less</span>(<span style="color:#000">j</span>, <span style="color:#000">i</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#a90d91">break</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000">h</span>.<span style="color:#000">Swap</span>(<span style="color:#000">i</span>, <span style="color:#000">j</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#000">j</span> = <span style="color:#000">i</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>down()</strong> 的实现如下，首先用  $j1 := 2*i + 1$ 计算对应子节点的索引，这里从 0 开始计算节点，并判断该索引是否超出长度 n，此外源码这里考虑到了可能溢出的问题，判断 j1 &lt; 0。</p>
<p>接着判断子节点中左节点和右节点的大小，选取更小者，最后判断更小者与父节点的大小关系，如果不满足交换则退出，否则交换子节点和父节点，并对子节点进行迭代。</p>
<p>最后返回结果时，根据初始索引和最后的索引值判断是否能够下沉。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">down</span>(<span style="color:#000">h</span> <span style="color:#000">Interface</span>, <span style="color:#000">i0</span>, <span style="color:#000">n</span> <span style="color:#a90d91">int</span>) <span style="color:#a90d91">bool</span> {
</span></span><span style="display:flex;"><span> <span style="color:#000">i</span> <span style="color:#000">:=</span> <span style="color:#000">i0</span>
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">for</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">j1</span> <span style="color:#000">:=</span> <span style="color:#1c01ce">2</span><span style="color:#000">*</span><span style="color:#000">i</span> <span style="color:#000">+</span> <span style="color:#1c01ce">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">if</span> <span style="color:#000">j1</span> <span style="color:#000">&gt;=</span> <span style="color:#000">n</span> <span style="color:#000">||</span> <span style="color:#000">j1</span> &lt; <span style="color:#1c01ce">0</span> { <span style="color:#177500">// j1 &lt; 0 after int overflow
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>   <span style="color:#a90d91">break</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000">j</span> <span style="color:#000">:=</span> <span style="color:#000">j1</span> <span style="color:#177500">// left child
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  <span style="color:#a90d91">if</span> <span style="color:#000">j2</span> <span style="color:#000">:=</span> <span style="color:#000">j1</span> <span style="color:#000">+</span> <span style="color:#1c01ce">1</span>; <span style="color:#000">j2</span> &lt; <span style="color:#000">n</span> <span style="color:#000">&amp;&amp;</span> <span style="color:#000">h</span>.<span style="color:#000">Less</span>(<span style="color:#000">j2</span>, <span style="color:#000">j1</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#000">j</span> = <span style="color:#000">j2</span> <span style="color:#177500">// = 2*i + 2  // right child
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a90d91">if</span> !<span style="color:#000">h</span>.<span style="color:#000">Less</span>(<span style="color:#000">j</span>, <span style="color:#000">i</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#a90d91">break</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#000">h</span>.<span style="color:#000">Swap</span>(<span style="color:#000">i</span>, <span style="color:#000">j</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#000">i</span> = <span style="color:#000">j</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">return</span> <span style="color:#000">i</span> &gt; <span style="color:#000">i0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Heap 根据 up() / down() 方法实现了其他暴露出来的 API。</p>
<p><strong>Init()</strong> 方法对堆进行初始化，<strong>Push() / Pop()</strong> 方法分别实现向堆中有序加入元素和弹出堆顶的操作，这两个操作依赖于 Interface 中实现的 Push 和 Pop。<strong>Remove()</strong> 方法将目标索引替换至队尾并重新有序化堆，最后调用 interface 中的 Pop 实现删除目标索引的元素。<strong>Fix()</strong> 方法用于堆指定元素重新有序化，这可以运用于直接修改堆中指定索引的元素后，调用 Fix 方法保证堆的有序化。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">Init</span>(<span style="color:#000">h</span> <span style="color:#000">Interface</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#177500">// heapify
</span></span></span><span style="display:flex;"><span><span style="color:#177500"></span> <span style="color:#000">n</span> <span style="color:#000">:=</span> <span style="color:#000">h</span>.<span style="color:#000">Len</span>()
</span></span><span style="display:flex;"><span> <span style="color:#a90d91">for</span> <span style="color:#000">i</span> <span style="color:#000">:=</span> <span style="color:#000">n</span><span style="color:#000">/</span><span style="color:#1c01ce">2</span> <span style="color:#000">-</span> <span style="color:#1c01ce">1</span>; <span style="color:#000">i</span> <span style="color:#000">&gt;=</span> <span style="color:#1c01ce">0</span>; <span style="color:#000">i</span><span style="color:#000">--</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#000">down</span>(<span style="color:#000">h</span>, <span style="color:#000">i</span>, <span style="color:#000">n</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">Push</span>(<span style="color:#000">h</span> <span style="color:#000">Interface</span>, <span style="color:#000">x</span> <span style="color:#000">any</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#000">h</span>.<span style="color:#000">Push</span>(<span style="color:#000">x</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">up</span>(<span style="color:#000">h</span>, <span style="color:#000">h</span>.<span style="color:#000">Len</span>()<span style="color:#000">-</span><span style="color:#1c01ce">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">Pop</span>(<span style="color:#000">h</span> <span style="color:#000">Interface</span>) <span style="color:#000">any</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">n</span> <span style="color:#000">:=</span> <span style="color:#000">h</span>.<span style="color:#000">Len</span>() <span style="color:#000">-</span> <span style="color:#1c01ce">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">h</span>.<span style="color:#000">Swap</span>(<span style="color:#1c01ce">0</span>, <span style="color:#000">n</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000">down</span>(<span style="color:#000">h</span>, <span style="color:#1c01ce">0</span>, <span style="color:#000">n</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">h</span>.<span style="color:#000">Pop</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">Remove</span>(<span style="color:#000">h</span> <span style="color:#000">Interface</span>, <span style="color:#000">i</span> <span style="color:#a90d91">int</span>) <span style="color:#000">any</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#000">n</span> <span style="color:#000">:=</span> <span style="color:#000">h</span>.<span style="color:#000">Len</span>() <span style="color:#000">-</span> <span style="color:#1c01ce">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> <span style="color:#000">n</span> <span style="color:#000">!=</span> <span style="color:#000">i</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#000">h</span>.<span style="color:#000">Swap</span>(<span style="color:#000">i</span>, <span style="color:#000">n</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a90d91">if</span> !<span style="color:#000">down</span>(<span style="color:#000">h</span>, <span style="color:#000">i</span>, <span style="color:#000">n</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#000">up</span>(<span style="color:#000">h</span>, <span style="color:#000">i</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">return</span> <span style="color:#000">h</span>.<span style="color:#000">Pop</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a90d91">func</span> <span style="color:#000">Fix</span>(<span style="color:#000">h</span> <span style="color:#000">Interface</span>, <span style="color:#000">i</span> <span style="color:#a90d91">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a90d91">if</span> !<span style="color:#000">down</span>(<span style="color:#000">h</span>, <span style="color:#000">i</span>, <span style="color:#000">h</span>.<span style="color:#000">Len</span>()) {
</span></span><span style="display:flex;"><span>		<span style="color:#000">up</span>(<span style="color:#000">h</span>, <span style="color:#000">i</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="nethttp">net/http</h3>
<h2 id="常用库">常用库</h2>
<h3 id="panjf2000ants">panjf2000/ants</h3>
<p><strong>ants</strong> 是一个 golang 语言中的协程池工具。</p>



        <style>
  .utterances {
    margin-top: 30svh;
    border-top: 1px solid var(--gray);
  }
</style>

<div id="utterances-container"></div>
<script>
  var repo = "huahuak/huahuak.github.io";
  var issueTerm = btoa(location.pathname);
  var theme = "github-light";
  (function () {
    var container = document.getElementById("utterances-container");
    var script = document.createElement("script");
    script.src = "https://utteranc.es/client.js";
    script.setAttribute("repo", repo);
    script.setAttribute("issue-term", issueTerm);
    script.setAttribute("theme", theme);
    script.crossorigin = "anonymous";
    script.async = true;
    container.appendChild(script);
  })();

</script>
      </main>
      <footer>  </footer>
    </div>
  </div>
</body>







<script>
  
  
  
  const localPrefix = "http://localhost:8080/Users/huahua/Library/Mobile%20Documents/com~apple~CloudDocs/HUAHUA/iNOTE";
  var localFunc = []
  window.onload = () => {
    fetch('http://localhost:8080/ping')
      .then((_1, _2) => { localFunc.forEach((f, _1, _2) => f()) })
      .catch(error => console.error('Error:', error));
  }

  
  
  
  function toggleVisibility() {
    let lbtn = document.getElementById("sidebar-lhs-button")
    let rbtn = document.getElementById("sidebar-rhs-button")
    var asideLayout = document.querySelector("div.aside-layout");
    var sidebar = document.getElementById("sidebar");
    if (sidebar.style.display === "none") {
      sidebar.style.display = "block"; 
      var rootStyles = getComputedStyle(document.documentElement);
      var asidePercent = rootStyles.getPropertyValue('--aside-percent');
      asideLayout.style.gridTemplateColumns = asidePercent;

      lbtn.style.display = "block"
      rbtn.style.display = "none"
    } else {
      sidebar.style.display = "none"; 
      asideLayout.style.gridTemplateColumns = '100svw';

      rbtn.style.display = "block"
      lbtn.style.display = "none"
    }
  }

  
  
  
  var oldScroll = 0
  function toggleSearch() {
    let search = document.getElementById("search")
    var main = document.getElementsByTagName("main")[0]
    if (search.style.display !== 'none') {
      search.style.display = 'none'
      main.scrollTop = oldScroll
    } else {
      search.style.display = 'block'
      document.getElementsByTagName('input')[0].focus()
      oldScroll = main.scrollTop
      main.scrollTop = 0
    }
  }

  
  
  
  var path = 'programming_languages\/golang\/golang.md'
  localFunc.push(() => {
    document.getElementsByClassName("edit-ico")[0].style.display = "block"
  })
  function toggleEdit() {
    fetch(localPrefix + "/" + path)
      .catch(error => console.error('Error:', error));
  }

  
  var mediaQuery = window.matchMedia('(max-width: 600px)');
  if (mediaQuery.matches) {
    var sidebar = document.getElementById('sidebar');
    sidebar.addEventListener('click', function (event) {
      if (event.target.tagName === 'A') {
        toggleVisibility()
      }
    });

    document.getElementById("sidebar-rhs-button").style.display = "block"
  }

  
  
  
  const prefix = 'programming_languages\/golang\/'
  var base = document.getElementsByTagName("main")[0]

  const wrapLink = link => {
    var pre = prefix
    if (link.includes("http")) {
      return link
    }
    if (link.startsWith("#")) {
      return link
    }
    if (link.startsWith("/")) {
      return link
    }
    if (prefix !== '/') {
      pre = '/' + prefix
    }
    link = pre + link
    link = link.replace(".md", "")
    return link
  }

  Array.from(base.getElementsByTagName('img')).forEach(item => {
    item.setAttribute('src', wrapLink(item.getAttribute('src')))
  })
  Array.from(base.getElementsByTagName('a')).forEach(item => {
    let old = item.getAttribute('href')
    let link = wrapLink(old)
    if (old !== link && link.includes(".")) {
      localFunc.push(() => {
        item.addEventListener('click', event => {
          event.preventDefault()
          fetch(localPrefix + link)
            .catch(error => console.error('Error:', error));
        })
      })
    }
    item.setAttribute('href', link)
  })

  
  
  
  var main = document.getElementsByTagName("main")[0]
  document.querySelectorAll('a[href^="#"]').forEach((v, _1, _2) => {
    v.addEventListener('click', function (e) {
      e.preventDefault();
      var targetId = this.getAttribute("href").slice(1);
      var targetElement = document.getElementById(targetId);
      if (targetElement) {
        main.scrollTo({
          top: targetElement.offsetTop - 54,
          behavior: 'smooth'
        });
      }
    })
  });

  
  
  
  main.addEventListener('scroll', function () {
    var sections = document.querySelectorAll('main h2, main h3');
    var scrollPosition = main.scrollTop + 54;
    for (var i = 0; i < sections.length; i++) {
      var currentSection = sections[i];
      if (scrollPosition >= sections[i].offsetTop && (i + 1 >= sections.length || scrollPosition < sections[i + 1].offsetTop)) {
        document.querySelector('#sidebar #TableOfContents a[href="#' + currentSection.id + '"]').style.fontWeight = 'bold';
      } else {
        document.querySelector('#sidebar #TableOfContents a[href="#' + currentSection.id + '"]').style.fontWeight = 'normal';
      }

    }
  });


  
  
  
  window.addEventListener('scroll', function () {
    window.scrollTo({ top: 0 })
  });
  window.addEventListener('DOMContentLoaded', (event) => {
    new PagefindUI({ element: "#search", showSubResults: true });
  });

</script>

</html>